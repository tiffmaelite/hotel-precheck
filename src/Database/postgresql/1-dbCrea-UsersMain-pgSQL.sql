CREATE TABLE USERS
(
  ID SERIAL,
  LOGIN VARCHAR(20) NOT NULL,
  ENCRYPTEDPASS VARCHAR(255) NOT NULL,
  ISRECEPTIONIST BOOLEAN DEFAULT '0' NOT NULL,
  ISMANAGERX BOOLEAN DEFAULT '0' NOT NULL,
  ISMANAGERZ BOOLEAN DEFAULT '0' NOT NULL,
  ISADMINISTRATOR BOOLEAN DEFAULT '0' NOT NULL,
  CONSTRAINT PK_USERS_ID PRIMARY KEY (ID),
  CONSTRAINT UQ_USERS_LOGIN UNIQUE (LOGIN)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);

--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_users
--BEFORE UPDATE ON users
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();

CREATE OR REPLACE FUNCTION  upsert_USERS()
RETURNS trigger
AS $$
BEGIN
WITH upsert AS
(
UPDATE USERS SET ENCRYPTEDPASS=new.ENCRYPTEDPASS, ISRECEPTIONIST=NEW.ISRECEPTIONIST, ISMANAGERX=NEW.ISMANAGERX, ISMANAGERZ=NEW.ISMANAGERZ, ISADMINISTRATOR=NEW.ISADMINISTRATOR WHERE LOGIN=new.LOGIN
  RETURNING USERS.*
)
INSERT INTO USERS (SELECT * FROM USERS a WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE b.LOGIN=a.LOGIN));
RETURN NULL;
 --LOOP
	-- first try to update the key
--UPDATE USERS SET ENCRYPTEDPASS=new.ENCRYPTEDPASS, ISRECEPTIONIST=NEW.ISRECEPTIONIST, ISMANAGERX=NEW.ISMANAGERX, ISMANAGERZ=NEW.ISMANAGERZ, ISADMINISTRATOR=NEW.ISADMINISTRATOR WHERE LOGIN=new.LOGIN;
--IF (FOUND) THEN --updated, do nothing
--RETURN NULL;
--END IF;
-- not there, so try to insert the key
-- if someone else inserts the same key concurrently,
-- we could get a unique-key failure
  --BEGIN
--INSERT INTO USERS(LOGIN, ENCRYPTEDPASS, ISRECEPTIONIST, ISMANAGERX, ISMANAGERZ, ISADMINISTRATOR) VALUES(NEW.LOGIN, NEW.ENCRYPTEDPASS, NEW.ISRECEPTIONIST, NEW.ISMANAGERX, NEW.ISMANAGERZ,NEW.ISADMINISTRATOR);
--RETURN NEW;
--EXCEPTION WHEN unique_violation THEN
	 -- do nothing, and loop to try the UPDATE again
 --END;
--END LOOP;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER z__upsertUSERS
BEFORE INSERT ON USERS
FOR EACH ROW WHEN (pg_trigger_depth() = 0) EXECUTE PROCEDURE upsert_USERS();
