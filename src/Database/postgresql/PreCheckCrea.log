CREATE ROLE
CREATE TABLESPACE
CREATE DATABASE
CREATE DATABASE
CREATE EXTENSION IF NOT EXISTS postgres_fdw;CREATE SERVER archivesrv FOREIGN DATA WRAPPER postgres_fdw OPTIONS ( host '/var/run/postgresql', port '5434', dbname 'precheckarchivesdb');CREATE USER MAPPING FOR precheck SERVER archivesrv OPTIONS ( user 'precheck', password 'hotel' );\q
CREATE EXTENSION
CREATE SERVER
CREATE USER MAPPING


_______________________

k=0





/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/0-dbCrea-extensionsTous-pgSQL.sql

CREATE EXTENSION IF NOT EXISTS plpgsql;
CREATE EXTENSION
CREATE EXTENSION IF NOT EXISTS dblink;
CREATE EXTENSION
CREATE EXTENSION IF NOT EXISTS postgres_fdw;
CREATE EXTENSION
CREATE EXTENSION IF NOT EXISTS adminpack;
CREATE EXTENSION
CREATE EXTENSION IF NOT EXISTS dict_int;
CREATE EXTENSION
CREATE EXTENSION IF NOT EXISTS dict_xsyn;
CREATE EXTENSION
CREATE EXTENSION IF NOT EXISTS autoinc;
CREATE EXTENSION
CREATE EXTENSION IF NOT EXISTS moddatetime;
CREATE EXTENSION
CREATE EXTENSION IF NOT EXISTS insert_username;
CREATE EXTENSION
--CREATE EXTENSION IF NOT EXISTS chkpass;
CREATE EXTENSION IF NOT EXISTS unaccent;
CREATE EXTENSION
CREATE EXTENSION IF NOT EXISTS intarray;
CREATE EXTENSION
CREATE EXTENSION IF NOT EXISTS hstore;
CREATE EXTENSION
LOAD 'auto_explain';
LOAD
CREATE EXTENSION IF NOT EXISTS plpgsql;
CREATE EXTENSION
CREATE EXTENSION IF NOT EXISTS dblink;
CREATE EXTENSION
CREATE EXTENSION IF NOT EXISTS postgres_fdw;
CREATE EXTENSION
CREATE EXTENSION IF NOT EXISTS adminpack;
CREATE EXTENSION
CREATE EXTENSION IF NOT EXISTS dict_int;
CREATE EXTENSION
CREATE EXTENSION IF NOT EXISTS dict_xsyn;
CREATE EXTENSION
CREATE EXTENSION IF NOT EXISTS autoinc;
CREATE EXTENSION
CREATE EXTENSION IF NOT EXISTS moddatetime;
CREATE EXTENSION
CREATE EXTENSION IF NOT EXISTS insert_username;
CREATE EXTENSION
--CREATE EXTENSION IF NOT EXISTS chkpass;
CREATE EXTENSION IF NOT EXISTS unaccent;
CREATE EXTENSION
CREATE EXTENSION IF NOT EXISTS intarray;
CREATE EXTENSION
CREATE EXTENSION IF NOT EXISTS hstore;
CREATE EXTENSION
LOAD 'auto_explain';
LOAD





/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/0-*Archives-pgSQL.sql






/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/0-*Main-pgSQL.sql



_______________________

k=1





/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-*Tous-pgSQL.sql






/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-AddressesArchives-pgSQL.sql

CREATE TABLE ADDRESSES
(
  ID SERIAL,
  CLIENT_ID INTEGER NOT NULL,
  CONTACT VARCHAR(30) NOT NULL,
  STREET VARCHAR(50) NOT NULL,
  NUMBER VARCHAR(6),
  COMPLEMENTARYLINE VARCHAR(50) NOT NULL,
  CITY VARCHAR(40) NOT NULL,
  ZIPCODE VARCHAR(9),
  STATE VARCHAR(15),
  COUNTRY VARCHAR(30) NOT NULL,
  PHONE VARCHAR(13),
  CONSTRAINT PK_ADDRESSES_ID PRIMARY KEY (ID),
  CONSTRAINT UQ_ADDRESSES_CONTACTADDRESS UNIQUE (CONTACT,STREET,NUMBER,CITY,STATE,COUNTRY),
  CONSTRAINT CK_VAL_ADDRESSES_PHONE CHECK (PHONE SIMILAR TO '[\+|00][[1-9]]{3}[[:DIGIT:]]{8}')
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_addresses
--BEFORE UPDATE ON addresses
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-BalanceLogArchives-pgSQL.sql

CREATE TABLE balancelog
(
  yearlog SMALLINT,
  monthlog SMALLINT,
  daylog SMALLINT,
  hourlog SMALLINT,
  balance DECIMAL,
  CONSTRAINT PK_BALANCELOG_DATE PRIMARY KEY (yearlog, monthlog, daylog, hourlog)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_balancelog
--BEFORE UPDATE ON balancelog
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-ClientsArchives-pgSQL.sql

CREATE TABLE CLIENTS
(
  ID SERIAL,
  NAME VARCHAR(35) NOT NULL,
  PHONE VARCHAR(15),
  EMAIL VARCHAR(50),
  IDCARDSCAN VARCHAR(100),
  NATIONALITY_ID INTEGER NOT NULL,
  HOMEADDRESS_ID INTEGER,
  ISCURRENT BOOLEAN DEFAULT '0' NOT NULL,
  CONSTRAINT PK_CLIENTS_ID PRIMARY KEY (ID),
  CONSTRAINT UQ_CLIENTS_EMAIL UNIQUE (EMAIL),
  CONSTRAINT UQ_CLIENTS_NAMEIDCARD UNIQUE (NAME, IDCARDSCAN),
  CONSTRAINT UQ_CLIENTS_NAMEHOME UNIQUE (NAME, HOMEADDRESS_ID),
  CONSTRAINT CK_VAL_CLIENTS_EMAIL CHECK(EMAIL SIMILAR TO '[[[:ALNUM:]\._%\+\-]+@[[:ALNUM:]\.-]+\.[[:ALPHA:]]+]?'),
  CONSTRAINT CK_VAL_CLIENTS_PHONE CHECK(PHONE SIMILAR TO '[[\+|00][[1-9]]{3}[[:DIGIT:]]{8}]?')
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_CLIENTS
--BEFORE UPDATE ON CLIENTS
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-GroupsArchives-pgSQL.sql

CREATE TABLE GROUPS
(
  ID SERIAL,
  NAME VARCHAR(25) NOT NULL,
  CONTACT_ID INTEGER,
  CONSTRAINT PK_GROUPS_ID PRIMARY KEY (ID),
  CONSTRAINT UQ_GROUPS_NAME UNIQUE (NAME)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_GROUPS
--BEFORE UPDATE ON GROUPS
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-NationalitiesArchives-pgSQL.sql

CREATE TABLE NATIONALITIES
(
  ID SERIAL,
  COUNTRY VARCHAR(511) NOT NULL,
  ISOCODE VARCHAR(2) NOT NULL,
  LONGISOCODE VARCHAR(3) NOT NULL,
  CODE VARCHAR(3) NOT NULL,
  CONSTRAINT PK_NATIONALITIES_ID PRIMARY KEY (ID),
  CONSTRAINT UQ_NATIONALITIES_CODE UNIQUE (CODE),
  CONSTRAINT UQ_NATIONALITIES_ISOCODE UNIQUE (ISOCODE),
  CONSTRAINT UQ_NATIONALITIES_LONGISOCODE UNIQUE (LONGISOCODE),
  CONSTRAINT UQ_NATIONALITIES_COUNTRY UNIQUE (COUNTRY)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_NATIONALITIES
--BEFORE UPDATE ON NATIONALITIES
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();





/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-AddressesArchiveMain-pgSQL.sql

CREATE FOREIGN TABLE ADDRESSES_ARCHIVE
(
  ID SERIAL,
  CLIENT_ID INTEGER NOT NULL,
  CONTACT VARCHAR(30) NOT NULL,
  STREET VARCHAR(50) NOT NULL,
  NUMBER VARCHAR(6),
  COMPLEMENTARYLINE VARCHAR(50) NOT NULL,
  CITY VARCHAR(40) NOT NULL,
  ZIPCODE VARCHAR(9),
  STATE VARCHAR(15),
  COUNTRY VARCHAR(30) NOT NULL,
  PHONE VARCHAR(13)
) SERVER archivesrv OPTIONS ( table_name 'ADDRESSES', use_remote_estimate 'true', updatable 'true' );
CREATE FOREIGN TABLE


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-BalanceLogArchiveMain-pgSQL.sql

CREATE FOREIGN TABLE balancelog_archive
(
  yearlog SMALLINT,
  monthlog SMALLINT,
  daylog SMALLINT,
  hourlog SMALLINT,
  balance DECIMAL
) SERVER archivesrv OPTIONS ( table_name 'balancelog', use_remote_estimate 'true', updatable 'true' );
CREATE FOREIGN TABLE


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-BillingsClientsMain-pgSQL.sql

CREATE TABLE billingsclients
(
  id SERIAL,
  client_id INTEGER NOT NULL,
  billing_id INTEGER,
  CONSTRAINT PK_BILLINGSCLIENTS_ID PRIMARY KEY (id),
  CONSTRAINT UQ_BILLINGSCLIENTS_BILLINGID UNIQUE (billing_id)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_billingsclients
--BEFORE UPDATE ON billingsclients
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
--ALTER TABLE BILLINGSCLIENTS ADD CONSTRAINT FK_BILLINGSCL_CLIENT FOREIGN KEY (CLIENT_ID) REFERENCES CLIENTS_ARCHIVE (ID) ON UPDATE NO ACTION ON DELETE NO ACTION;
CREATE OR REPLACE FUNCTION  fkbillingsclientsreferencesclientsarchives() RETURNS TRIGGER AS $$
BEGIN
IF (NOT EXISTS (SELECT 1 FROM CLIENTS_ARCHIVE WHERE ID = NEW.CLIENT_ID)) THEN
RAISE EXCEPTION 'Foreign key exception!';
END IF;
END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION
CREATE TRIGGER tr_fkbillingsclientsreferencesclientsarchives BEFORE INSERT OR UPDATE ON billingsclients
FOR EACH ROW
EXECUTE PROCEDURE fkbillingsclientsreferencesclientsarchives();
CREATE TRIGGER
CREATE TABLE training_billingsclients
(
  id SERIAL,
  client_id INTEGER NOT NULL,
  billing_id INTEGER,
  CONSTRAINT PK_TRAININGBILLINGSCLIENTS_ID PRIMARY KEY (id),
  CONSTRAINT UQ_TRAININGBILLINGSCLIENTS_BILLINGID UNIQUE (billing_id)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_trainingbillingsclients
--BEFORE UPDATE ON training_billingsclients
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
--ALTER TABLE TRAINING_BILLINGSCLIENTS ADD CONSTRAINT FK_TRAININGBILLINGSCL_CLIENT FOREIGN KEY (CLIENT_ID) REFERENCES CLIENTS_ARCHIVE (ID) ON UPDATE NO ACTION ON DELETE NO ACTION;
CREATE OR REPLACE FUNCTION  fktrainingbillingsclientsreferencesclientsarchives() RETURNS TRIGGER AS $$
BEGIN
IF  (NOT EXISTS (SELECT 1 FROM CLIENTS_ARCHIVE WHERE ID = NEW.CLIENT_ID)) THEN
RAISE EXCEPTION 'Foreign key exception!';
END IF;
END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION
CREATE TRIGGER tr_fktrainingbillingsclientsreferencesclientsarchives BEFORE INSERT OR UPDATE ON training_billingsclients
FOR EACH ROW
EXECUTE PROCEDURE fktrainingbillingsclientsreferencesclientsarchives();
CREATE TRIGGER


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-BillingsGroupsMain-pgSQL.sql

CREATE TABLE BILLINGSGROUPS
(
  ID SERIAL,
  GROUP_ID INTEGER NOT NULL,
  BILLING_ID INTEGER,
  CONSTRAINT PK_BILLINGSGROUPS_ID PRIMARY KEY (ID),
  CONSTRAINT UQ_BILLINGSGROUPS_BILLINGID UNIQUE (billing_id)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_billingsgroups
--BEFORE UPDATE ON billingsgroups
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
--ALTER TABLE BILLINGSGROUPS ADD CONSTRAINT FK_BILLINGSGR_GROUP FOREIGN KEY (GROUP_ID) REFERENCES GROUPS_ARCHIVE (ID) ON UPDATE NO ACTION ON DELETE NO ACTION,
CREATE OR REPLACE FUNCTION  fkbillingsgroupsreferencesgroupsarchives() RETURNS TRIGGER AS $$
BEGIN
IF (NOT EXISTS (SELECT 1 FROM GROUPS_ARCHIVE WHERE ID = NEW.GROUP_ID)) THEN
RAISE EXCEPTION 'Foreign key exception!';
END IF;
END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION
CREATE TRIGGER tr_fkbillingsgroupsreferencesgroupsarchives BEFORE INSERT OR UPDATE ON billingsgroups
FOR EACH ROW
EXECUTE PROCEDURE fkbillingsgroupsreferencesgroupsarchives();
CREATE TRIGGER
CREATE TABLE TRAINING_BILLINGSGROUPS
(
  ID SERIAL,
  GROUP_ID INTEGER NOT NULL,
  BILLING_ID INTEGER,
  CONSTRAINT PK_TRAININGBILLINGSGROUPS_ID PRIMARY KEY (ID),
  CONSTRAINT UQ_TRAININGBILLINGSGROUPS_BILLINGID UNIQUE (billing_id)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_trainingbillingsgroups
--BEFORE UPDATE ON training_billingsgroups
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
--ALTER TABLE TRAINING_BILLINGSGROUPS ADD CONSTRAINT FK_TRAININGBILLINGSGR_GROUP FOREIGN KEY (GROUP_ID) REFERENCES GROUPS_ARCHIVE (ID) ON UPDATE NO ACTION ON DELETE NO ACTION,
CREATE OR REPLACE FUNCTION  fktrainingbillingsgroupsreferencesgroupsarchives() RETURNS TRIGGER AS $$
BEGIN
IF (NOT EXISTS (SELECT 1 FROM GROUPS_ARCHIVE WHERE ID = NEW.GROUP_ID)) THEN
RAISE EXCEPTION 'Foreign key exception!';
END IF;
END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION
CREATE TRIGGER tr_fktrainingbillingsgroupsreferencesgroupsarchives BEFORE INSERT OR UPDATE ON training_billingsgroups
FOR EACH ROW
EXECUTE PROCEDURE fktrainingbillingsgroupsreferencesgroupsarchives();
CREATE TRIGGER


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-BillingsMain-pgSQL.sql

CREATE TABLE BILLINGS
(
  ID SERIAL,
  BILLINGSTYPE_ID INTEGER,
  NBROOMS SMALLINT NOT NULL,
  BOOKING_ID INTEGER,
  BILLINGADDRESS_ID INTEGER NOT NULL,
  NBADULTS SMALLINT DEFAULT 0,
  NBCHILDREN SMALLINT DEFAULT 0,
  ARRIVINGDATE DATE NOT NULL,
  DEPARTUREDATE DATE NOT NULL,
  EXPECTEDDEPARTUREDATE DATE,
  ISCLOSED BOOLEAN DEFAULT '0' NOT NULL,
  NOTE VARCHAR(255),
  CONSTRAINT PK_BILLINGS_ID PRIMARY KEY (ID),
  CONSTRAINT CK_POS_BILLINGS_NBADULTS CHECK (NBADULTS >= 0),
  CONSTRAINT CK_GREA_BILLINGS_EXDEPARRDATE CHECK (EXPECTEDDEPARTUREDATE >= ARRIVINGDATE),
  CONSTRAINT CK_GREA_BILLINGS_DEPARRDATE CHECK (DEPARTUREDATE >= ARRIVINGDATE)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_billings
--BEFORE UPDATE ON billings
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
--ALTER TABLE BILLINGS ADD CONSTRAINT FK_BILLINGS_ADDRESS FOREIGN KEY (BILLINGADDRESS_ID) REFERENCES ADDRESSES_ARCHIVE (ID) ON UPDATE NO ACTION ON DELETE NO ACTION,
CREATE OR REPLACE FUNCTION  fkbillingsreferencesaddressesarchives() RETURNS TRIGGER AS $$
BEGIN
 IF (NOT  EXISTS (SELECT 1 FROM ADDRESSES_ARCHIVE WHERE ID = NEW.BILLINGADDRESS_ID)) THEN
RAISE EXCEPTION 'Foreign key exception!';
END IF;
END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION
CREATE TRIGGER tr_fkbillingsreferencesaddressesarchives BEFORE INSERT OR UPDATE ON billings
FOR EACH ROW
EXECUTE PROCEDURE fkbillingsreferencesaddressesarchives();
CREATE TRIGGER
CREATE TABLE TRAINING_BILLINGS
(
  ID SERIAL,
  BILLINGSTYPE_ID INTEGER,
  NBROOMS SMALLINT NOT NULL,
  BOOKING_ID INTEGER,
  BILLINGADDRESS_ID INTEGER NOT NULL,
  NBADULTS SMALLINT DEFAULT 0,
  NBCHILDREN SMALLINT DEFAULT 0,
  ARRIVINGDATE DATE NOT NULL,
  DEPARTUREDATE DATE NOT NULL,
  EXPECTEDDEPARTUREDATE DATE,
  ISCLOSED BOOLEAN DEFAULT '0' NOT NULL,
  NOTE VARCHAR(255),
  CONSTRAINT PK_TRAININGBILLINGS_ID PRIMARY KEY (ID),
  CONSTRAINT CK_POS_TRAININGBILLINGS_NBADULTS CHECK (NBADULTS >= 0),
  CONSTRAINT CK_GREA_TRAININGBILLINGS_EXDEPARRDATE CHECK (EXPECTEDDEPARTUREDATE >= ARRIVINGDATE),
  CONSTRAINT CK_GREA_TRAININGBILLINGS_DEPARRDATE CHECK (DEPARTUREDATE >= ARRIVINGDATE)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_billings
--BEFORE UPDATE ON billings
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
--ALTER TABLE TRAINING_BILLINGS ADD CONSTRAINT FK_TRAININGBILLINGS_ADDRESS FOREIGN KEY (BILLINGADDRESS_ID) REFERENCES ADDRESSES_ARCHIVE (ID) ON UPDATE NO ACTION ON DELETE NO ACTION,
CREATE OR REPLACE FUNCTION  fktrainingbillingsreferencesaddressesarchives() RETURNS TRIGGER AS $$
BEGIN
IF (NOT  EXISTS (SELECT 1 FROM ADDRESSES_ARCHIVE WHERE ID = NEW.BILLINGADDRESS_ID)) THEN
RAISE EXCEPTION 'Foreign key exception!';
END IF;
END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION
CREATE TRIGGER tr_fktrainingbillingsreferencesaddressesarchives BEFORE INSERT OR UPDATE ON training_billings
FOR EACH ROW
EXECUTE PROCEDURE fktrainingbillingsreferencesaddressesarchives();
CREATE TRIGGER


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-BillingsTypesMain-pgSQL.sql

CREATE TABLE BILLINGSTYPES
(
  ID SERIAL,
  LABEL VARCHAR(20),
  NBBILLS SMALLINT NOT NULL,
  CONSTRAINT PK_BILLINGSTYPES_ID PRIMARY KEY (ID),
  CONSTRAINT UQ_BILLINGSTYPES_LABEL UNIQUE (LABEL)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_BILLINGSTYPES
--BEFORE UPDATE ON BILLINGSTYPES
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-BillsMain-pgSQL.sql

CREATE TABLE BILLS
(
  ID SERIAL,
  BILLING_ID INTEGER NOT NULL,
  BILLINGBILLID INTEGER NOT NULL,
  BILLTYPE_ID INTEGER NOT NULL,
  NOTE VARCHAR(255),
  CONSTRAINT PK_BILLS_ID PRIMARY KEY (ID),
  CONSTRAINT UQ_BILLS_IDBILLID UNIQUE (BILLING_ID,BILLINGBILLID)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_bills
--BEFORE UPDATE ON bills
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
CREATE TABLE TRAINING_BILLS
(
  ID SERIAL,
  BILLING_ID INTEGER NOT NULL,
  BILLINGBILLID INTEGER NOT NULL,
  BILLTYPE_ID INTEGER NOT NULL,
  NOTE VARCHAR(255),
  CONSTRAINT PK_TRAININGBILLS_ID PRIMARY KEY (ID),
  CONSTRAINT UQ_TRAININGBILLS_IDBILLID UNIQUE (BILLING_ID,BILLINGBILLID)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_TRAININGbills
--BEFORE UPDATE ON TRAINING_BILLS
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-BillsTypesMain-pgSQL.sql

CREATE TABLE BILLSTYPES
(
  ID SERIAL,
  LABEL VARCHAR(20),
  CONSTRAINT PK_BILLSTYPES_ID PRIMARY KEY (ID),
  CONSTRAINT UQ_BILLSTYPES_LABEL UNIQUE (LABEL)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_BILLSTYPES
--BEFORE UPDATE ON BILLSTYPES
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-BookingsMain-pgSQL.sql

CREATE TABLE BOOKINGS
(
  ID SERIAL,
  CLIENT_ID INTEGER NOT NULL,
  ROOMTYPE_ID INTEGER NOT NULL,
  NBADULTS SMALLINT DEFAULT 0,
  NBCHILDREN SMALLINT DEFAULT 0,
  EXPECTEDARRIVINGDATE DATE NOT NULL,
  EXPECTEDDEPARTUREDATE DATE NOT NULL,
  BOOKINGDATE DATE NOT NULL,
  CONFIRMATIONDATE DATE,
  CANCELATIONDATE DATE,
  NOTE VARCHAR(255),
  CONSTRAINT PK_BOOKINGS_ID PRIMARY KEY (ID),
  CONSTRAINT UQ_BOOKINGS_CLIENTARRIVING UNIQUE (CLIENT_ID,EXPECTEDARRIVINGDATE),
  CONSTRAINT UQ_BOOKINGS_CLIENTDEPARTURE UNIQUE (CLIENT_ID,EXPECTEDDEPARTUREDATE),
  CONSTRAINT CK_POS_BOOKINGS_NBADULTS CHECK (NBADULTS >= 0),
  CONSTRAINT CK_POS_BOOKINGS_NBCHILDREN CHECK (NBCHILDREN >= 0)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--CREATE TRIGGER z__minupdate_BOOKINGS
--BEFORE UPDATE ON BOOKINGS
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
CREATE OR REPLACE FUNCTION  fkBOOKINGSreferencesclientsarchives() RETURNS TRIGGER AS $$
BEGIN
IF (NOT EXISTS (SELECT 1 FROM CLIENTS_ARCHIVE WHERE ID = new.CLIENT_ID)) THEN
RAISE EXCEPTION 'Foreign key exception!';
END IF;
END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION
CREATE TRIGGER tr_fkBOOKINGSreferencesclientsarchives BEFORE INSERT OR UPDATE ON BOOKINGS
FOR EACH ROW
EXECUTE PROCEDURE fkBOOKINGSreferencesclientsarchives();
CREATE TRIGGER
CREATE OR REPLACE FUNCTION  upsert_BOOKINGS(newinput hstore) RETURNS VOID AS $inner$
BEGIN
WITH upsert1 AS (
	UPDATE BOOKINGS SET ROOMTYPE_ID=newinput -> 'ROOMTYPE_ID', EXPECTEDDEPARTUREDATE=newinput -> 'EXPECTEDDEPARTUREDATE', NBADULTS=newinput -> 'NBADULTS', NBCHILDREN=newinput -> 'NBCHILDREN', BOOKINGDATE=newinput -> 'BOOKINGDATE', CONFIRMATIONDATE=newinput -> 'CONFIRMATIONDATE', CANCELATIONDATE=newinput -> 'CANCELATIONDATE', NOTE=newinput -> 'NOTE' WHERE CLIENT_ID=newinput -> 'CLIENT_ID' AND EXPECTEDARRIVINGDATE=newinput -> 'EXPECTEDARRIVINGDATE' RETURNING BOOKINGS.*
  ), upsert2 AS (
	UPDATE BOOKINGS SET ROOMTYPE_ID=newinput -> 'ROOMTYPE_ID', EXPECTEDARRIVINGDATE=newinput -> 'EXPECTEDARRIVINGDATE', NBADULTS=newinput -> 'NBADULTS', NBCHILDREN=newinput -> 'NBCHILDREN', BOOKINGDATE=newinput -> 'BOOKINGDATE', CONFIRMATIONDATE=newinput -> 'CONFIRMATIONDATE', CANCELATIONDATE=newinput -> 'CANCELATIONDATE', NOTE=newinput -> 'NOTE' WHERE CLIENT_ID=newinput -> 'CLIENT_ID' AND EXPECTEDDEPARTUREDATE=newinput -> 'EXPECTEDDEPARTUREDATE' RETURNING BOOKINGS.*
  )
INSERT INTO BOOKINGS (
  SELECT * FROM BOOKINGS
	WHERE NOT EXISTS (
	SELECT 1 FROM upsert1 b1 WHERE (CLIENT_ID=b1.CLIENT_ID AND EXPECTEDARRIVINGDATE=b1.EXPECTEDARRIVINGDATE)
	  UNION ALL SELECT 1 FROM upsert2 b2 WHERE (CLIENT_ID=b2.CLIENT_ID AND EXPECTEDDEPARTUREDATE=b2.EXPECTEDDEPARTUREDATE)
	)
  );
END;
$inner$ LANGUAGE plpgsql;
CREATE FUNCTION
CREATE TABLE TRAINING_BOOKINGS
(
  ID SERIAL,
  CLIENT_ID INTEGER NOT NULL,
  ROOMTYPE_ID INTEGER NOT NULL,
  NBADULTS SMALLINT DEFAULT 0,
  NBCHILDREN SMALLINT DEFAULT 0,
  EXPECTEDARRIVINGDATE DATE NOT NULL,
  EXPECTEDDEPARTUREDATE DATE NOT NULL,
  BOOKINGDATE DATE NOT NULL,
  CONFIRMATIONDATE DATE,
  CANCELATIONDATE DATE,
  NOTE VARCHAR(255),
  CONSTRAINT PK_TRAININGBOOKINGS_ID PRIMARY KEY (ID),
  CONSTRAINT UQ_TRAININGBOOKINGS_CLIENTARRIVING UNIQUE (CLIENT_ID,EXPECTEDARRIVINGDATE),
  CONSTRAINT UQ_TRAININGBOOKINGS_CLIENTDEPARTURE UNIQUE (CLIENT_ID,EXPECTEDDEPARTUREDATE),
  CONSTRAINT CK_POS_TRAININGBOOKINGS_NBADULTS CHECK (NBADULTS >= 0),
  CONSTRAINT CK_POS_TRAININGBOOKINGS_NBCHILDREN CHECK (NBCHILDREN >= 0)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_TRAININGBOOKINGS
--BEFORE UPDATE ON TRAINING_BOOKINGS
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
CREATE OR REPLACE FUNCTION  fktrainingbookingsreferencesclientsarchives() RETURNS TRIGGER AS $$
BEGIN
IF (NOT EXISTS (SELECT 1 FROM CLIENTS_ARCHIVE WHERE ID = new.CLIENT_ID)) THEN
RAISE EXCEPTION 'Foreign key exception!';
END IF;
END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION
CREATE TRIGGER tr_fktrainingbookingsreferencesclientsarchives BEFORE INSERT OR UPDATE ON training_bookings
FOR EACH ROW
EXECUTE PROCEDURE fktrainingbookingsreferencesclientsarchives();
CREATE TRIGGER
CREATE OR REPLACE FUNCTION  upsert_trainingbookings() RETURNS VOID AS $inner$
BEGIN
WITH upsert1 AS (
	UPDATE training_bookings SET ROOMTYPE_ID=newinput -> 'ROOMTYPE_ID', EXPECTEDDEPARTUREDATE=newinput -> 'EXPECTEDDEPARTUREDATE', NBADULTS=newinput -> 'NBADULTS', NBCHILDREN=newinput -> 'NBCHILDREN', BOOKINGDATE=newinput -> 'BOOKINGDATE', CONFIRMATIONDATE=newinput -> 'CONFIRMATIONDATE', CANCELATIONDATE=newinput -> 'CANCELATIONDATE', NOTE=newinput -> 'NOTE' WHERE CLIENT_ID=newinput -> 'CLIENT_ID' AND EXPECTEDARRIVINGDATE=newinput -> 'EXPECTEDARRIVINGDATE' RETURNING BOOKINGS.*
  ), upsert2 AS (
	UPDATE training_bookings SET ROOMTYPE_ID=newinput -> 'ROOMTYPE_ID', EXPECTEDARRIVINGDATE=newinput -> 'EXPECTEDARRIVINGDATE', NBADULTS=newinput -> 'NBADULTS', NBCHILDREN=newinput -> 'NBCHILDREN', BOOKINGDATE=newinput -> 'BOOKINGDATE', CONFIRMATIONDATE=newinput -> 'CONFIRMATIONDATE', CANCELATIONDATE=newinput -> 'CANCELATIONDATE', NOTE=newinput -> 'NOTE' WHERE CLIENT_ID=newinput -> 'CLIENT_ID' AND EXPECTEDDEPARTUREDATE=newinput -> 'EXPECTEDDEPARTUREDATE' RETURNING BOOKINGS.*
  )
INSERT INTO training_bookings (
  SELECT * FROM training_bookings
	WHERE NOT EXISTS (
	SELECT 1 FROM upsert1 b1 WHERE (CLIENT_ID=b1.CLIENT_ID AND EXPECTEDARRIVINGDATE=b1.EXPECTEDARRIVINGDATE)
	  UNION ALL SELECT 1 FROM upsert2 b2 WHERE (CLIENT_ID=b2.CLIENT_ID AND EXPECTEDDEPARTUREDATE=b2.EXPECTEDDEPARTUREDATE)
	)
  );
END;
$inner$ LANGUAGE plpgsql;
CREATE FUNCTION


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-ChargedServicesMain-pgSQL.sql

CREATE TABLE CHARGEDSERVICES
(
  SERVICE_ID INTEGER NOT NULL,
  BILL_ID INTEGER NOT NULL,
  RECEPTIONIST_ID INTEGER NOT NULL,
  INVOICINGDATE DATE NOT NULL,
  QUANTITY SMALLINT NOT NULL,
  CHARGEDUNITPRICE DECIMAL,
  VAT_PERCENTAGE DECIMAL,
  ISPRINTED BOOLEAN DEFAULT '0' NOT NULL,
  ISPAYED BOOLEAN DEFAULT '0' NOT NULL,
  PAIEMENTDATE DATE,
  CONSTRAINT PK_CHARGEDSERVICES_SERVICEBILL PRIMARY KEY (SERVICE_ID,BILL_ID),
  CONSTRAINT CK_POS_CHARGEDSERVICES_VAT CHECK (VAT_PERCENTAGE >= 0),
  CONSTRAINT CK_POS_CHARGEDSERVICES_PRICE CHECK (CHARGEDUNITPRICE >= 0)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--CREATE TRIGGER z__minupdate_CHARGEDSERVICES
--BEFORE UPDATE ON CHARGEDSERVICES
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
CREATE TABLE TRAINING_CHARGEDSERVICES
(
  SERVICE_ID INTEGER NOT NULL,
  BILL_ID INTEGER NOT NULL,
  RECEPTIONIST_ID INTEGER NOT NULL,
  INVOICINGDATE DATE NOT NULL,
  QUANTITY SMALLINT NOT NULL,
  CHARGEDUNITPRICE DECIMAL,
  VAT_PERCENTAGE DECIMAL,
  ISPRINTED BOOLEAN DEFAULT '0' NOT NULL,
  ISPAYED BOOLEAN DEFAULT '0' NOT NULL,
  PAIEMENTDATE DATE,
  CONSTRAINT PK_TRAININGCHARGEDSERVICES_SERVICEBILL PRIMARY KEY (SERVICE_ID,BILL_ID),
  CONSTRAINT CK_POS_TRAININGCHARGEDSERVICES_VAT CHECK (VAT_PERCENTAGE >= 0),
  CONSTRAINT CK_POS_TRAININGCHARGEDSERVICES_PRICE CHECK (CHARGEDUNITPRICE >= 0)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_TRAININGCHARGEDSERVICES
--BEFORE UPDATE ON TRAINING_CHARGEDSERVICES
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-ClientsArchiveMain-pgSQL.sql

CREATE FOREIGN TABLE CLIENTS_ARCHIVE
(
  ID SERIAL,
  NAME VARCHAR(35) NOT NULL,
  PHONE VARCHAR(15),
  EMAIL VARCHAR(50),
  IDCARDSCAN VARCHAR(100),
  NATIONALITY_ID INTEGER NOT NULL,
  HOMEADDRESS_ID INTEGER,
  ISCURRENT BOOLEAN DEFAULT '0' NOT NULL
) SERVER archivesrv OPTIONS ( table_name 'clients', use_remote_estimate 'true', updatable 'true' );
CREATE FOREIGN TABLE


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-DailyBalCountMain-pgSQL.sql

CREATE TABLE dailybalcount
(
  dcreationtime TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  dyearlog SMALLINT,
  dmonthlog SMALLINT,
  ddaylog SMALLINT,
  dbalance DECIMAL,
  CONSTRAINT PK_DAYLYBALCOUNT_CREATION PRIMARY KEY (dcreationtime)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_dailybalcount
--BEFORE UPDATE ON dailybalcount
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-GroupsArchiveMain-pgSQL.sql

CREATE FOREIGN TABLE GROUPS_ARCHIVE
(
  ID SERIAL,
  NAME VARCHAR(25) NOT NULL,
  CONTACT_ID INTEGER
) SERVER archivesrv OPTIONS ( table_name 'groups', use_remote_estimate 'true', updatable 'true' );
CREATE FOREIGN TABLE


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-HourlyBalCountMain-pgSQL.sql

CREATE TABLE hourlybalcount
(
  hcreationtime TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  hyearlog SMALLINT,
  hmonthlog SMALLINT,
  hdaylog SMALLINT,
  hhourlog SMALLINT,
  hbalance DECIMAL,
  CONSTRAINT PK_HOURLYBALCOUNT_CREATION PRIMARY KEY (hcreationtime)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_hourlybalcount
--BEFORE UPDATE ON hourlybalcount
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-MonthlyBalCountMain-pgSQL.sql

CREATE TABLE monthlybalcount
(
  mcreationtime TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  myearlog SMALLINT,
  mmonthlog SMALLINT,
  mbalance DECIMAL,
  CONSTRAINT PK_MONTHLYBALCOUNT_CREATION PRIMARY KEY (mcreationtime)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_monthlybalcount
--BEFORE UPDATE ON monthlybalcount
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-NationalitiesArchiveMain-pgSQL.sql

CREATE FOREIGN TABLE NATIONALITIES_ARCHIVE
(
ID SERIAL,
COUNTRY VARCHAR(511) NOT NULL,
ISOCODE VARCHAR(2) NOT NULL,
LONGISOCODE VARCHAR(3) NOT NULL,
CODE VARCHAR(3) NOT NULL
) SERVER archivesrv OPTIONS ( table_name 'nationalities', use_remote_estimate 'true', updatable 'true' );
CREATE FOREIGN TABLE


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-ReportsTypesMain-pgSQL.sql

CREATE TABLE REPORTSTYPES
(
  ID SERIAL,
  LABEL VARCHAR(30),
  DESCRIPTION VARCHAR(255),
  GENERATIONQUERY VARCHAR(1024),
  CONSTRAINT PK_REPORTSTYPES_ID PRIMARY KEY (ID),
  CONSTRAINT UQ_REPORTSTYPES_QUERY UNIQUE (GENERATIONQUERY),
  CONSTRAINT UQ_REPORTSTYPES_LABEL UNIQUE (LABEL)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_REPORTSTYPES
--BEFORE UPDATE ON REPORTSTYPES
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-RoomsMain-pgSQL.sql

CREATE TABLE ROOMS
(
  ID SERIAL,
  ROOMTYPE_ID INTEGER NOT NULL,
  NUMBER SMALLINT NOT NULL,
  FLOOR SMALLINT NOT NULL,
  ISCLEANED BOOLEAN DEFAULT '1' NOT NULL,
  CONSTRAINT PK_ROOMS_ID PRIMARY KEY (ID),
  CONSTRAINT UQ_ROOMS_NUMBER UNIQUE (NUMBER)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_ROOMS
--BEFORE UPDATE ON ROOMS
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-RoomsOccupationMain-pgSQL.sql

CREATE TABLE ROOMSOCCUPATIONS
(
  ID SERIAL,
  ROOM_ID INTEGER NOT NULL,
  BILLING_ID INTEGER NOT NULL,
  ARRIVINGDATE DATE NOT NULL,
  DEPARTUREDATE DATE NOT NULL,
  CONSTRAINT PK_ROOMSOCC_ROOMBILLING PRIMARY KEY (ROOM_ID, BILLING_ID),
  CONSTRAINT UQ_ROOMSOCC_ROOMARRIVINGDATE UNIQUE (ROOM_ID, ARRIVINGDATE),
  CONSTRAINT UQ_ROOMSOCC_ROOMDEPARTUREDATE UNIQUE (ROOM_ID, DEPARTUREDATE)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_ROOMSOCCUPATIONS
--BEFORE UPDATE ON ROOMSOCCUPATIONS
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-RoomsTypesMain-pgSQL.sql

CREATE TABLE ROOMSTYPES
(
  ID SERIAL,
  LABEL VARCHAR(20) NOT NULL,
  DESCRIPTION VARCHAR(255),
  PRICEMIN DECIMAL NOT NULL,
  PRICEMAX DECIMAL,
  CONSTRAINT PK_ROOMSTYPES_ID PRIMARY KEY (ID),
  CONSTRAINT UQ_ROOMSTYPES_LABEL UNIQUE (LABEL),
  CONSTRAINT CK_ORD_ROOMSTYPES_PRICES CHECK (PRICEMAX IS NULL OR PRICEMAX >= PRICEMIN)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_roomstypes
--BEFORE UPDATE ON roomstypes
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-ServicesDetailsMain-pgSQL.sql

CREATE TABLE SERVICESDETAILS
(
  SERVICE_ID INTEGER NOT NULL,
  SERVICEFIELD_ID INTEGER NOT NULL,
  FIELDVALUE VARCHAR(255),
  CONSTRAINT PK_SERVICESDETAILS_ID PRIMARY KEY (SERVICE_ID, SERVICEFIELD_ID)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_SERVICESDETAILS
--BEFORE UPDATE ON SERVICESDETAILS
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-ServicesFamiliesMain-pgSQL.sql

CREATE TABLE SERVICESFAMILIES
(
  ID SERIAL,
  LABEL VARCHAR(25) NOT NULL,
  CONSTRAINT PK_SERVICESFAMILIES_ID PRIMARY KEY (ID),
  CONSTRAINT UQ_SERVICESFAMILIES_LABEL UNIQUE (LABEL)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_SERVICESFAMILIES
--BEFORE UPDATE ON SERVICESFAMILIES
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-ServicesFieldsMain-pgSQL.sql

CREATE TABLE SERVICESFIELDS
(
  ID SERIAL,
  LABEL VARCHAR(25) NOT NULL,
  SQLTYPE VARCHAR(100) DEFAULT 'TEXT' NOT NULL,
  CONSTRAINT PK_SERVICESFIELDS_ID PRIMARY KEY (ID),
  CONSTRAINT UQ_SERVICESFIELDS_LABEL UNIQUE (LABEL)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_SERVICESFIELDS
--BEFORE UPDATE ON SERVICESFIELDS
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-ServicesMain-pgSQL.sql

CREATE TABLE SERVICES
(
  ID SERIAL,
  SERVICETYPE_ID INTEGER NOT NULL,
  CODE SMALLINT DEFAULT 0,
  NAME VARCHAR(100) NOT NULL,
  ISAVAILABLE BOOLEAN DEFAULT '1'  NOT NULL,
  CONSTRAINT PK_SERVICES_ID PRIMARY KEY (ID),
  CONSTRAINT UQ_SERVICES_NAME UNIQUE (NAME),
  CONSTRAINT UQ_SERVICES_CODETYPE UNIQUE (CODE, SERVICETYPE_ID),
  CONSTRAINT CK_POS_SERVICES_CODE CHECK (CODE >= 0)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_SERVICES
--BEFORE UPDATE ON SERVICES
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-ServicesTypesMain-pgSQL.sql

CREATE TABLE SERVICESTYPES
(
 ID SERIAL,
 CODE SMALLINT DEFAULT 0,
 LABEL VARCHAR(25) NOT NULL,
 SERVICEFAMILY_ID INTEGER NOT NULL,
 VAT_ID INTEGER NOT NULL,
 ROOMNEEDED BOOLEAN DEFAULT '1' NOT NULL,
 CONSTRAINT PK_SERVICESTYPES_ID PRIMARY KEY (ID),
 CONSTRAINT UQ_SERVICESTYPES_CODEFAMILY UNIQUE (SERVICEFAMILY_ID, CODE),
 CONSTRAINT UQ_SERVICESTYPES_LABEL UNIQUE (LABEL)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_SERVICESTYPES
--BEFORE UPDATE ON SERVICESTYPES
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-TaxesMain-pgSQL.sql

CREATE TABLE TAXES
(
  ID SERIAL,
  LABEL VARCHAR(20) NOT NULL,
  PERCENTAGE DECIMAL,
  STARTDATE DATE DEFAULT NULL,
  ENDDATE DATE DEFAULT NULL,
  CONSTRAINT PK_TAXES_ID PRIMARY KEY (ID),
  CONSTRAINT CK_POS_TAXES_PERCENTAGE CHECK (PERCENTAGE >= 0),
  CONSTRAINT CK_ORD_TAXES_DATES CHECK (STARTDATE IS NULL OR ENDDATE IS NULL OR ENDDATE >= STARTDATE)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_taxes
--BEFORE UPDATE ON taxes
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-TraineesMain-pgSQL.sql

CREATE TABLE TRAINEES
(
  ID SERIAL,
  LOGIN VARCHAR(20) NOT NULL,
  ENCRYPTEDPASS VARCHAR(255) NOT NULL,
  ISACTIVATED BOOLEAN DEFAULT '1' NOT NULL,
  CONSTRAINT PK_TRAINEES_ID PRIMARY KEY (ID),
  CONSTRAINT UQ_TRAINEES_LOGIN UNIQUE (LOGIN)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_trainees
--BEFORE UPDATE ON TRAINEES
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-UsersMain-pgSQL.sql

CREATE TABLE USERS
(
  ID SERIAL,
  LOGIN VARCHAR(20) NOT NULL,
  ENCRYPTEDPASS VARCHAR(255) NOT NULL,
  ISRECEPTIONIST BOOLEAN DEFAULT '0' NOT NULL,
  ISMANAGERX BOOLEAN DEFAULT '0' NOT NULL,
  ISMANAGERZ BOOLEAN DEFAULT '0' NOT NULL,
  ISADMINISTRATOR BOOLEAN DEFAULT '0' NOT NULL,
  CONSTRAINT PK_USERS_ID PRIMARY KEY (ID),
  CONSTRAINT UQ_USERS_LOGIN UNIQUE (LOGIN)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_users
--BEFORE UPDATE ON users
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/1-dbCrea-YearlyBalCountMain-pgSQL.sql

CREATE TABLE yearlybalcount
(
  ycreationtime TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  yyearlog SMALLINT,
  ybalance DECIMAL,
  CONSTRAINT PK_YEARLYBALCOUNT_CREATION PRIMARY KEY (ycreationtime)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);
CREATE TABLE
--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_yearlybalcount
--BEFORE UPDATE ON yearlybalcount
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();


_______________________

k=2





/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/2-*Tous-pgSQL.sql






/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/2-dbCrea-constraintsArchives-pgSQL.sql

ALTER TABLE GROUPS
  ADD CONSTRAINT FK_GROUPS_CONTACTCLIENT FOREIGN KEY (CONTACT_ID) REFERENCES CLIENTS (ID) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE
ALTER TABLE CLIENTS
  ADD CONSTRAINT FK_CLIENTS_ADDRESS FOREIGN KEY (HOMEADDRESS_ID) REFERENCES ADDRESSES (ID) ON UPDATE CASCADE ON DELETE SET DEFAULT,
  ADD CONSTRAINT FK_CLIENTS_NATIONALITY FOREIGN KEY (NATIONALITY_ID) REFERENCES NATIONALITIES (ID) ON UPDATE CASCADE ON DELETE SET DEFAULT;
ALTER TABLE
ALTER TABLE ADDRESSES
  ADD CONSTRAINT FK_ADDRESSES_CLIENT FOREIGN KEY (CLIENT_ID) REFERENCES CLIENTS (ID) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE





/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/2-dbCrea-constraintsMain-pgSQL.sql

ALTER TABLE SERVICESTYPES
 ADD CONSTRAINT FK_SERVICESTYPES_TAXES FOREIGN KEY (VAT_ID) REFERENCES TAXES (ID) ON UPDATE CASCADE ON DELETE CASCADE,
 ADD CONSTRAINT FK_SERVICESTYPES_FAMILY FOREIGN KEY (SERVICEFAMILY_ID) REFERENCES SERVICESFAMILIES (ID) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE
ALTER TABLE SERVICES
 ADD CONSTRAINT FK_SERVICES_TYPE FOREIGN KEY (SERVICETYPE_ID) REFERENCES SERVICESTYPES (ID) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE
ALTER TABLE ROOMS
 ADD CONSTRAINT FK_ROOMS_TYPE FOREIGN KEY (ROOMTYPE_ID) REFERENCES ROOMSTYPES (ID) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE
ALTER TABLE CHARGEDSERVICES
 ADD CONSTRAINT FK_CHARGEDSERVICES_USER FOREIGN KEY (RECEPTIONIST_ID) REFERENCES USERS (ID) ON UPDATE CASCADE ON DELETE CASCADE,
 ADD CONSTRAINT FK_CHARGEDSERVICES_SERVICE FOREIGN KEY (SERVICE_ID) REFERENCES SERVICES (ID) ON UPDATE CASCADE ON DELETE CASCADE,
 ADD CONSTRAINT FK_CHARGEDSERVICES_BILL FOREIGN KEY (BILL_ID) REFERENCES BILLS (ID) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE
ALTER TABLE TRAINING_CHARGEDSERVICES
 ADD CONSTRAINT FK_TRAININGCHARGEDSERVICES_TRAINEE FOREIGN KEY (RECEPTIONIST_ID) REFERENCES TRAINEES (ID) ON UPDATE CASCADE ON DELETE CASCADE,
 ADD CONSTRAINT FK_TRAININGCHARGEDSERVICES_SERVICE FOREIGN KEY (SERVICE_ID) REFERENCES SERVICES (ID) ON UPDATE CASCADE ON DELETE CASCADE,
 ADD CONSTRAINT FK_TRAININGCHARGEDSERVICES_BILL FOREIGN KEY (BILL_ID) REFERENCES TRAINING_BILLS (ID) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE
ALTER TABLE BILLS
 ADD CONSTRAINT FK_BILLS_BILLING FOREIGN KEY (BILLING_ID) REFERENCES BILLINGS (ID) ON UPDATE CASCADE ON DELETE CASCADE,
 ADD CONSTRAINT FK_BILLS_TYPE FOREIGN KEY (BILLTYPE_ID) REFERENCES BILLSTYPES (ID) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE
ALTER TABLE TRAINING_BILLS
 ADD CONSTRAINT FK_TRAININGBILLS_BILLING FOREIGN KEY (BILLING_ID) REFERENCES TRAINING_BILLINGS (ID) ON UPDATE CASCADE ON DELETE CASCADE,
 ADD CONSTRAINT FK_TRAININGBILLS_TYPE FOREIGN KEY (BILLTYPE_ID) REFERENCES BILLSTYPES (ID) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE
ALTER TABLE ROOMSOCCUPATIONS
 ADD CONSTRAINT FK_ROOMSOCC_ROOM FOREIGN KEY (ROOM_ID) REFERENCES ROOMS (ID) ON UPDATE NO ACTION ON DELETE NO ACTION,
 ADD CONSTRAINT FK_ROOMSOCC_BILLINGSID FOREIGN KEY (BILLING_ID) REFERENCES BILLINGS (ID) ON UPDATE NO ACTION ON DELETE NO ACTION;
ALTER TABLE
ALTER TABLE BILLINGSGROUPS
 --ADD CONSTRAINT FK_BILLINGSGR_GROUP FOREIGN KEY (GROUP_ID) REFERENCES GROUPS_ARCHIVE (ID) ON UPDATE CASCADE ON DELETE RESTRICT,
 ADD CONSTRAINT FK_BILLINGSGR_BILLINGSID FOREIGN KEY (BILLING_ID) REFERENCES BILLINGS (ID) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE
ALTER TABLE TRAINING_BILLINGSGROUPS
 --ADD CONSTRAINT FK_TRAININGBILLINGSGR_GROUP FOREIGN KEY (GROUP_ID) REFERENCES GROUPS_ARCHIVE (ID) ON UPDATE CASCADE ON DELETE RESTRICT,
 ADD CONSTRAINT FK_TRAININGBILLINGSGR_BILLINGSID FOREIGN KEY (BILLING_ID) REFERENCES TRAINING_BILLINGS (ID) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE
ALTER TABLE BILLINGSCLIENTS
 --ADD CONSTRAINT FK_BILLINGSCL_CLIENT FOREIGN KEY (CLIENT_ID) REFERENCES CLIENTS_ARCHIVE (ID) ON UPDATE CASCADE ON DELETE RESTRICT,
 ADD CONSTRAINT FK_BILLINGSCL_BILLINGSID FOREIGN KEY (BILLING_ID) REFERENCES BILLINGS (ID) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE
ALTER TABLE TRAINING_BILLINGSCLIENTS
 --ADD CONSTRAINT FK_TRAININGBILLINGSCL_CLIENT FOREIGN KEY (CLIENT_ID) REFERENCES CLIENTS_ARCHIVE (ID) ON UPDATE CASCADE ON DELETE RESTRICT,
 ADD CONSTRAINT FK_TRAININGBILLINGSCL_BILLINGSID FOREIGN KEY (BILLING_ID) REFERENCES TRAINING_BILLINGS (ID) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE
ALTER TABLE BILLINGS
 --ADD CONSTRAINT FK_BILLINGS_ADDRESS FOREIGN KEY (BILLINGADDRESS_ID) REFERENCES ADDRESSES_ARCHIVE (ID) ON UPDATE CASCADE ON DELETE CASCADE,
 ADD CONSTRAINT FK_BILLINGS_TYPE FOREIGN KEY (BILLINGSTYPE_ID) REFERENCES BILLINGSTYPES (ID) ON UPDATE CASCADE ON DELETE CASCADE,
 ADD CONSTRAINT FK_BILLINGS_BOOKING FOREIGN KEY (BOOKING_ID) REFERENCES BOOKINGS (ID) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE
ALTER TABLE TRAINING_BILLINGS
 --ADD CONSTRAINT FK_TRAININGBILLINGS_ADDRESS FOREIGN KEY (BILLINGADDRESS_ID) REFERENCES ADDRESSES_ARCHIVE (ID) ON UPDATE CASCADE ON DELETE CASCADE,
 ADD CONSTRAINT FK_TRAININGBILLINGS_TYPE FOREIGN KEY (BILLINGSTYPE_ID) REFERENCES BILLINGSTYPES (ID) ON UPDATE CASCADE ON DELETE CASCADE,
 ADD CONSTRAINT FK_TRAININGBILLINGS_BOOKING FOREIGN KEY (BOOKING_ID) REFERENCES TRAINING_BOOKINGS (ID) ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE
ALTER TABLE BOOKINGS
 --ADD CONSTRAINT FK_BOOKINGS_CLIENT FOREIGN KEY (CLIENT_ID) REFERENCES CLIENTS_ARCHIVE (ID) ON UPDATE CASCADE ON DELETE CASCADE,
 ADD CONSTRAINT FK_BOOKINGS_ROOMTYPE FOREIGN KEY (ROOMTYPE_ID) REFERENCES ROOMSTYPES (ID) ON UPDATE CASCADE ON DELETE NO ACTION;
ALTER TABLE
ALTER TABLE TRAINING_BOOKINGS
 --ADD CONSTRAINT FK_TRAININGBOOKINGS_CLIENT FOREIGN KEY (CLIENT_ID) REFERENCES CLIENTS_ARCHIVE (ID) ON UPDATE CASCADE ON DELETE CASCADE,
 ADD CONSTRAINT FK_TRAININGBOOKINGS_ROOMTYPE FOREIGN KEY (ROOMTYPE_ID) REFERENCES ROOMSTYPES (ID) ON UPDATE CASCADE ON DELETE NO ACTION;
ALTER TABLE


_______________________

k=3





/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/3-dbCrea-Function-genupsertIDTous-pgSQL.sql

CREATE OR REPLACE FUNCTION  gen_upsertID(tablename VARCHAR, returningField VARCHAR DEFAULT NULL)
RETURNS VARCHAR
AS $main$
DECLARE
  dynfunc VARCHAR;
  col RECORD;
  updatestring VARCHAR;
BEGIN
updatestring=' SET ';
 FOR col IN SELECT column_name FROM information_schema.columns WHERE table_name=tablename AND column_name NOT ILIKE 'id%' LOOP
	updatestring=updatestring||' '||col.column_name||'=newinput -> '''||col.column_name||''', ';
 END LOOP;
  updatestring=trim(trailing ', ' from updatestring);

  dynfunc='CREATE OR REPLACE FUNCTION  genupsertID_'||tablename||'(newinput hstore, knownid INTEGER DEFAULT 0) RETURNS VOID AS $inner$ BEGIN ';
  dynfunc=dynfunc||' WITH upsert AS ( UPDATE '||tablename||' '||updatestring||' WHERE id=knownid RETURNING '||tablename||'.* ) ';
  dynfunc=dynfunc||' INSERT INTO '||tablename||' (SELECT * FROM '||tablename||' WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE id=knownid)) ';
  IF returningField IS NOT NULL THEN
	dynfunc=dynfunc||' RETURNING '||returningField||' ';
  END IF;
  dynfunc=dynfunc||' ; END; $inner$ LANGUAGE plpgsql; ';

	EXECUTE dynfunc;
 RETURN dynfunc;
END;
$main$ LANGUAGE plpgsql
VOLATILE;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION  genall_upsertID()
RETURNS VOID
AS $main$
DECLARE
tablenames RECORD;
newfunc VARCHAR;
BEGIN
 FOR tablenames IN SELECT table_name FROM information_schema.tables WHERE table_schema!='information_schema' AND table_schema!='pg_catalog' AND table_type='BASE TABLE' LOOP
	SELECT INTO newfunc gen_upsertID(tablenames.table_name);
	EXECUTE newfunc;
  END LOOP;
END;
$main$ LANGUAGE plpgsql
VOLATILE;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION  gen_upsertID(tablename VARCHAR, returningField VARCHAR DEFAULT NULL)
RETURNS VARCHAR
AS $main$
DECLARE
  dynfunc VARCHAR;
  col RECORD;
  updatestring VARCHAR;
BEGIN
updatestring=' SET ';
 FOR col IN SELECT column_name FROM information_schema.columns WHERE table_name=tablename AND column_name NOT ILIKE 'id%' LOOP
	updatestring=updatestring||' '||col.column_name||'=newinput -> '''||col.column_name||''', ';
 END LOOP;
  updatestring=trim(trailing ', ' from updatestring);

  dynfunc='CREATE OR REPLACE FUNCTION  genupsertID_'||tablename||'(newinput hstore, knownid INTEGER DEFAULT 0) RETURNS VOID AS $inner$ BEGIN ';
  dynfunc=dynfunc||' WITH upsert AS ( UPDATE '||tablename||' '||updatestring||' WHERE id=knownid RETURNING '||tablename||'.* ) ';
  dynfunc=dynfunc||' INSERT INTO '||tablename||' (SELECT * FROM '||tablename||' WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE id=knownid)) ';
  IF returningField IS NOT NULL THEN
	dynfunc=dynfunc||' RETURNING '||returningField||' ';
  END IF;
  dynfunc=dynfunc||' ; END; $inner$ LANGUAGE plpgsql; ';

	EXECUTE dynfunc;
 RETURN dynfunc;
END;
$main$ LANGUAGE plpgsql
VOLATILE;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION  genall_upsertID()
RETURNS VOID
AS $main$
DECLARE
tablenames RECORD;
newfunc VARCHAR;
BEGIN
 FOR tablenames IN SELECT table_name FROM information_schema.tables WHERE table_schema!='information_schema' AND table_schema!='pg_catalog' AND table_type='BASE TABLE' LOOP
	SELECT INTO newfunc gen_upsertID(tablenames.table_name);
	EXECUTE newfunc;
  END LOOP;
END;
$main$ LANGUAGE plpgsql
VOLATILE;
CREATE FUNCTION


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/3-dbCrea-Function-genupsertTous-pgSQL.sql

CREATE OR REPLACE FUNCTION  gen_upsert(tablename VARCHAR, updatestring VARCHAR, wherecondition VARCHAR, returningField VARCHAR DEFAULT NULL)
RETURNS VARCHAR
AS $main$
DECLARE
  dynfunc VARCHAR;
  dynsql VARCHAR;
BEGIN
  dynfunc='CREATE OR REPLACE FUNCTION  genupsert_'||tablename||'(newinput hstore) RETURNS ';
  IF returningField IS NOT NULL THEN
	dynfunc = dynfunc||' TEXT AS $inner$ DECLARE returnVar TEXT; ';
  ELSE
	dynfunc = dynfunc||' VOID AS $inner$ ';
  END IF;
  dynfunc= dynfunc||' BEGIN ';
  dynsql = 'WITH upsert AS ( UPDATE '||tablename||' SET '||regexp_replace(regexp_replace(updatestring,'new\.(\w+)(\s|,)','newinput -> ''\1''\2','ig'),'new\.(\w+)$','newinput -> ''\1'' ','ig')||' WHERE '||regexp_replace(regexp_replace(wherecondition,'new\.(\w+)(\s|,)','newinput -> ''\1''\2','ig'),'new\.(\w+)$','newinput -> ''\1'' ','ig')||' RETURNING '||tablename||'.* ) ';
  dynsql=dynsql||' INSERT INTO '||tablename||' (SELECT * FROM '||tablename||' WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE '||regexp_replace(wherecondition,'new','b','ig')||')) ';
  IF returningField IS NOT NULL THEN
	--dynsql=dynsql||' RETURNING '||returningField||' INTO returnVar; ';
	dynsql=dynsql||'; SELECT '||returningField||' INTO returnVar FROM '||tablename||' WHERE '||regexp_replace(regexp_replace(wherecondition,'new\.(\w+)(\s|,)','newinput -> ''\1''\2','ig'),'new\.(\w+)$','newinput -> ''\1'' ','ig')||';';
	dynfunc=dynfunc||' '||dynsql||'  RAISE NOTICE '||quote_literal(dynsql)||';  RAISE NOTICE '' ==> %'', returnVar; RETURN CAST(returnVar AS TEXT); ';
  ELSE
	dynfunc=dynfunc||' '||dynsql||';';
  END IF;
  dynfunc=dynfunc||' EXECUTE query; END; $inner$ LANGUAGE plpgsql; ';
	EXECUTE dynfunc;
 RETURN dynfunc;
END;
$main$ LANGUAGE plpgsql
VOLATILE;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION  gen_upsert(tablename VARCHAR, updatestring VARCHAR, wherecondition VARCHAR, returningField VARCHAR DEFAULT NULL)
RETURNS VARCHAR
AS $main$
DECLARE
  dynfunc VARCHAR;
  dynsql VARCHAR;
BEGIN
  dynfunc='CREATE OR REPLACE FUNCTION  genupsert_'||tablename||'(newinput hstore) RETURNS ';
  IF returningField IS NOT NULL THEN
	dynfunc = dynfunc||' TEXT AS $inner$ DECLARE returnVar TEXT; ';
  ELSE
	dynfunc = dynfunc||' VOID AS $inner$ ';
  END IF;
  dynfunc= dynfunc||' BEGIN ';
  dynsql = 'WITH upsert AS ( UPDATE '||tablename||' SET '||regexp_replace(regexp_replace(updatestring,'new\.(\w+)(\s|,)','newinput -> ''\1''\2','ig'),'new\.(\w+)$','newinput -> ''\1'' ','ig')||' WHERE '||regexp_replace(regexp_replace(wherecondition,'new\.(\w+)(\s|,)','newinput -> ''\1''\2','ig'),'new\.(\w+)$','newinput -> ''\1'' ','ig')||' RETURNING '||tablename||'.* ) ';
  dynsql=dynsql||' INSERT INTO '||tablename||' (SELECT * FROM '||tablename||' WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE '||regexp_replace(wherecondition,'new','b','ig')||')) ';
  IF returningField IS NOT NULL THEN
	--dynsql=dynsql||' RETURNING '||returningField||' INTO returnVar; ';
	dynsql=dynsql||'; SELECT '||returningField||' INTO returnVar FROM '||tablename||' WHERE '||regexp_replace(regexp_replace(wherecondition,'new\.(\w+)(\s|,)','newinput -> ''\1''\2','ig'),'new\.(\w+)$','newinput -> ''\1'' ','ig')||';';
	dynfunc=dynfunc||' '||dynsql||'  RAISE NOTICE '||quote_literal(dynsql)||';  RAISE NOTICE '' ==> %'', returnVar; RETURN CAST(returnVar AS TEXT); ';
  ELSE
	dynfunc=dynfunc||' '||dynsql||';';
  END IF;
  dynfunc=dynfunc||' EXECUTE query; END; $inner$ LANGUAGE plpgsql; ';
	EXECUTE dynfunc;
 RETURN dynfunc;
END;
$main$ LANGUAGE plpgsql
VOLATILE;
CREATE FUNCTION


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/3-dbCrea-Function-genupsertmultTous-pgSQL.sql

CREATE OR REPLACE FUNCTION  gen_upsertmult(tablename VARCHAR, updatestrings VARCHAR[], whereconditions VARCHAR[], returningField VARCHAR DEFAULT NULL)
RETURNS VARCHAR
AS $main$
DECLARE
  dynfunc VARCHAR;
  dynsql VARCHAR;
  mult INTEGER;
  updatestring VARCHAR;
  wherecondition VARCHAR;
BEGIN
  mult=least(array_length(whereconditions,1),array_length(updatestrings,1));

  dynfunc='CREATE OR REPLACE FUNCTION  genupsert_'||tablename||'(newinput hstore) RETURNS ';
  IF returningField IS NOT NULL THEN
	dynfunc = dynfunc||' TEXT AS $inner$ DECLARE returnVar TEXT; ';
  ELSE
	dynfunc = dynfunc||' VOID AS $inner$ ';
  END IF;
  dynfunc= dynfunc||' BEGIN ';
  dynsql=' WITH ';
  FOR i IN 1..mult
  LOOP
	wherecondition=regexp_replace(regexp_replace(whereconditions[i],'new\.(\w+)(\s|,)','newinput -> ''\1''\2','ig'),'new\.(\w+)$','newinput -> ''\1''','ig');
	updatestring=regexp_replace(regexp_replace(updatestrings[i],'new\.(\w+)(\s|,)','newinput -> ''\1''\2','ig'),'new\.(\w+)$','newinput -> ''\1'' ','ig');

	dynsql=dynsql||' upsert'||i||' AS ( UPDATE '||tablename||' SET '||updatestring||' WHERE '||wherecondition||' RETURNING '||tablename||'.* ), ';
  END LOOP;
  dynsql=trim(trailing ', ' from dynsql);
  dynsql=dynsql||' INSERT INTO '||tablename||' (SELECT * FROM '||tablename||' WHERE NOT EXISTS ( ';
  FOR i IN 1..mult
  LOOP
  dynsql=dynsql||' SELECT 1 FROM  upsert'||i||' b'||i||' WHERE ('||regexp_replace(whereconditions[i],'new','b'||i,'ig')||') UNION ALL ';
  END LOOP;
  dynsql=trim(trailing 'UNION ALL ' from dynsql);
  dynsql=dynsql||' ))';
  IF returningField IS NOT NULL THEN
	--dynsql=dynsql||' RETURNING '||returningField||' INTO returnVar; ';
	dynsql=dynsql||'; SELECT '||returningField||' INTO returnVar FROM '||tablename||' WHERE ';
	FOR i IN 1..mult
	LOOP
	wherecondition=regexp_replace(regexp_replace(whereconditions[i],'new\.(\w+)(\s|,)','newinput -> ''\1''\2','ig'),'new\.(\w+)$','newinput -> ''\1''','ig');
	dynsql=dynsql||' '||wherecondition||' OR ';
	END LOOP;
	dynsql=trim(trailing 'OR ' from dynsql);
	dynsql=dynsql||';';
		dynfunc=dynfunc||' '||dynsql||' RAISE NOTICE '||quote_literal(dynsql)||'; RAISE NOTICE '' ==> %'', returnVar; RETURN CAST(returnVar AS TEXT); ';
	  ELSE
		dynfunc=dynfunc||' '||dynsql||';';
	  END IF;
	  dynfunc=dynfunc||' EXECUTE query; END; $inner$ LANGUAGE plpgsql; ';
	EXECUTE dynfunc;

 RETURN dynfunc;
END;
$main$ LANGUAGE plpgsql
VOLATILE;
CREATE FUNCTION
CREATE OR REPLACE FUNCTION  gen_upsertmult(tablename VARCHAR, updatestrings VARCHAR[], whereconditions VARCHAR[], returningField VARCHAR DEFAULT NULL)
RETURNS VARCHAR
AS $main$
DECLARE
  dynfunc VARCHAR;
  dynsql VARCHAR;
  mult INTEGER;
  updatestring VARCHAR;
  wherecondition VARCHAR;
BEGIN
  mult=least(array_length(whereconditions,1),array_length(updatestrings,1));

  dynfunc='CREATE OR REPLACE FUNCTION  genupsert_'||tablename||'(newinput hstore) RETURNS ';
  IF returningField IS NOT NULL THEN
	dynfunc = dynfunc||' TEXT AS $inner$ DECLARE returnVar TEXT; ';
  ELSE
	dynfunc = dynfunc||' VOID AS $inner$ ';
  END IF;
  dynfunc= dynfunc||' BEGIN ';
  dynsql=' WITH ';
  FOR i IN 1..mult
  LOOP
	wherecondition=regexp_replace(regexp_replace(whereconditions[i],'new\.(\w+)(\s|,)','newinput -> ''\1''\2','ig'),'new\.(\w+)$','newinput -> ''\1''','ig');
	updatestring=regexp_replace(regexp_replace(updatestrings[i],'new\.(\w+)(\s|,)','newinput -> ''\1''\2','ig'),'new\.(\w+)$','newinput -> ''\1'' ','ig');

	dynsql=dynsql||' upsert'||i||' AS ( UPDATE '||tablename||' SET '||updatestring||' WHERE '||wherecondition||' RETURNING '||tablename||'.* ), ';
  END LOOP;
  dynsql=trim(trailing ', ' from dynsql);
  dynsql=dynsql||' INSERT INTO '||tablename||' (SELECT * FROM '||tablename||' WHERE NOT EXISTS ( ';
  FOR i IN 1..mult
  LOOP
  dynsql=dynsql||' SELECT 1 FROM  upsert'||i||' b'||i||' WHERE ('||regexp_replace(whereconditions[i],'new','b'||i,'ig')||') UNION ALL ';
  END LOOP;
  dynsql=trim(trailing 'UNION ALL ' from dynsql);
  dynsql=dynsql||' ))';
  IF returningField IS NOT NULL THEN
	--dynsql=dynsql||' RETURNING '||returningField||' INTO returnVar; ';
	dynsql=dynsql||'; SELECT '||returningField||' INTO returnVar FROM '||tablename||' WHERE ';
	FOR i IN 1..mult
	LOOP
	wherecondition=regexp_replace(regexp_replace(whereconditions[i],'new\.(\w+)(\s|,)','newinput -> ''\1''\2','ig'),'new\.(\w+)$','newinput -> ''\1''','ig');
	dynsql=dynsql||' '||wherecondition||' OR ';
	END LOOP;
	dynsql=trim(trailing 'OR ' from dynsql);
	dynsql=dynsql||';';
		dynfunc=dynfunc||' '||dynsql||' RAISE NOTICE '||quote_literal(dynsql)||'; RAISE NOTICE '' ==> %'', returnVar; RETURN CAST(returnVar AS TEXT); ';
	  ELSE
		dynfunc=dynfunc||' '||dynsql||';';
	  END IF;
	  dynfunc=dynfunc||' EXECUTE query; END; $inner$ LANGUAGE plpgsql; ';
	EXECUTE dynfunc;

 RETURN dynfunc;
END;
$main$ LANGUAGE plpgsql
VOLATILE;
CREATE FUNCTION


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/3-dbCrea-Function-pivotcodeTous-pgSQL.sql

-- PL/pgSQL code to create pivot tables with automatic column names
-- Eric Minikel, CureFFI.org - 2013-03-19
-- Modified by Tiffany Grenier (2013-07-08) for taking SQL types in other database
-- prerequisite: install the tablefunc module before using crosstab
CREATE EXTENSION IF NOT EXISTS tablefunc;
CREATE EXTENSION
-- sourcetablename: name of source table you want to pivot
-- rowc: the name of the column in "sourcetablename" you want to be the rows
-- colc: the name of the column in "tablename" you want to be the columns
-- cellc: an aggregate expressiON determining how the cell values will be created
-- celldatatype: the name of the column in "tablename" you want to be the desired data type for the cells
-- tablename: name of the table cONtaining columns names values and types
-- sourcecolc: the name of the column in "sourcetablename" matching to column "colc"
-- rowctype: the type of datas in column "rowc"
--CREATE OR REPLACE FUNCTION  pivotcode (sourcetablename VARCHAR, rowc VARCHAR, colc VARCHAR, cellc VARCHAR, celldatatype VARCHAR, tablename VARCHAR, sourcecolc VARCHAR, rowctype VARCHAR)
CREATE OR REPLACE FUNCTION genpivotcode (sourcetablename VARCHAR, rowc VARCHAR, colc VARCHAR, cellc VARCHAR, celldatatype VARCHAR, tablename VARCHAR, sourcecolc VARCHAR, rowctype VARCHAR, pivottable VARCHAR)
RETURNS VARCHAR
AS $$

DECLARE
  columns_sql VARCHAR;
  crosstab_sql VARCHAR;
  columnlist VARCHAR;
BEGIN
	-- 1. retrieve list of column names and types.

	--in case of a single content type
	--celldtype = 'VARCHAR';
	--columns_sql = 'SELECT string_agg(DISTINCT ''_''||'||colc||'||'' '||celldtype||''', '', '' ORDER BY ''_''||'||colc||'||'' '||celldtype||''') FROM '||sourcetablename||';';

	--in case content type is given in the same table as categories
	columns_sql = 'SELECT string_agg(''_''||'||colc||'||'' ''||'||celldatatype||'||'''', '', '') FROM (SELECT DISTINCT '||colc||', '||celldatatype||', '||tablename||'.id FROM '||tablename||' JOIN '||sourcetablename||' ON '||tablename||'.id = '||sourcetablename||'.'||sourcecolc||' ORDER BY '||tablename||'.id) AS source;';

	EXECUTE columns_sql INTO columnlist;
	--RAISE NOTICE 'columns_sql: %', columns_sql;

	-- 2. set up the crosstab query [crosstab(text source_sql, text category_sql)]

	-- The main limitation of the single-parameter form of crosstab is that it treats all values in a group alike, inserting each value INTO the first available column. If you want the value columns to correspond to specific categories of data, and some groups might not have data for some of the categories, that doesn't work well. The two-parameter form of crosstab handles this case by providing an explicit list of the categories corresponding to the output columns.
	-- The first parameter is a SQL statement that produces the source set of data and returns one row_name column, one category column, and one value column, as well as possible extra columns (which are expected to be the same for all rows with the same row_name value) between the first and the last two columns previously mentioned.
	-- The second parameter is a SQL statement that produces a duplicates-free non-empty set of datas

	--crosstab_sql = 'SELECT * INTO '||pivottable||' FROM crosstab (''SELECT '||rowc||', '||sourcecolc||', string_agg('||cellc||','''','''') FROM '||sourcetablename||' GROUP BY '||rowc||','||sourcecolc||' ORDER BY '||rowc||','||sourcecolc||''', ''SELECT DISTINCT '||sourcecolc||' FROM  '||sourcetablename||' ORDER BY '||sourcecolc||''') AS '||pivottable||' ('||rowc||' '||rowctype||', '||columnlist||');'; -- actual names and types of the output columns, since the crosstab function is declared to return setof record.

	crosstab_sql = 'CREATE TABLE '||pivottable||' AS (SELECT * FROM crosstab (''SELECT '||rowc||', '||sourcecolc||', string_agg('||cellc||','''','''') FROM '||sourcetablename||' GROUP BY '||rowc||','||sourcecolc||' ORDER BY '||rowc||','||sourcecolc||''', ''SELECT DISTINCT '||sourcecolc||' FROM  '||sourcetablename||' ORDER BY '||sourcecolc||''') AS '||pivottable||' ('||rowc||' '||rowctype||', '||columnlist||'));';

EXECUTE crosstab_sql;

	--RAISE NOTICE 'crosstab_sql: %', crosstab_sql;
	RETURN crosstab_sql;

END;
$$ LANGUAGE plpgsql VOLATILE;
CREATE FUNCTION
-- PL/pgSQL code to create pivot tables with automatic column names
-- Eric Minikel, CureFFI.org - 2013-03-19
-- Modified by Tiffany Grenier (2013-07-08) for taking SQL types in other database
-- prerequisite: install the tablefunc module before using crosstab
CREATE EXTENSION IF NOT EXISTS tablefunc;
CREATE EXTENSION
-- sourcetablename: name of source table you want to pivot
-- rowc: the name of the column in "sourcetablename" you want to be the rows
-- colc: the name of the column in "tablename" you want to be the columns
-- cellc: an aggregate expressiON determining how the cell values will be created
-- celldatatype: the name of the column in "tablename" you want to be the desired data type for the cells
-- tablename: name of the table cONtaining columns names values and types
-- sourcecolc: the name of the column in "sourcetablename" matching to column "colc"
-- rowctype: the type of datas in column "rowc"
--CREATE OR REPLACE FUNCTION  pivotcode (sourcetablename VARCHAR, rowc VARCHAR, colc VARCHAR, cellc VARCHAR, celldatatype VARCHAR, tablename VARCHAR, sourcecolc VARCHAR, rowctype VARCHAR)
CREATE OR REPLACE FUNCTION genpivotcode (sourcetablename VARCHAR, rowc VARCHAR, colc VARCHAR, cellc VARCHAR, celldatatype VARCHAR, tablename VARCHAR, sourcecolc VARCHAR, rowctype VARCHAR, pivottable VARCHAR)
RETURNS VARCHAR
AS $$

DECLARE
  columns_sql VARCHAR;
  crosstab_sql VARCHAR;
  columnlist VARCHAR;
BEGIN
	-- 1. retrieve list of column names and types.

	--in case of a single content type
	--celldtype = 'VARCHAR';
	--columns_sql = 'SELECT string_agg(DISTINCT ''_''||'||colc||'||'' '||celldtype||''', '', '' ORDER BY ''_''||'||colc||'||'' '||celldtype||''') FROM '||sourcetablename||';';

	--in case content type is given in the same table as categories
	columns_sql = 'SELECT string_agg(''_''||'||colc||'||'' ''||'||celldatatype||'||'''', '', '') FROM (SELECT DISTINCT '||colc||', '||celldatatype||', '||tablename||'.id FROM '||tablename||' JOIN '||sourcetablename||' ON '||tablename||'.id = '||sourcetablename||'.'||sourcecolc||' ORDER BY '||tablename||'.id) AS source;';

	EXECUTE columns_sql INTO columnlist;
	--RAISE NOTICE 'columns_sql: %', columns_sql;

	-- 2. set up the crosstab query [crosstab(text source_sql, text category_sql)]

	-- The main limitation of the single-parameter form of crosstab is that it treats all values in a group alike, inserting each value INTO the first available column. If you want the value columns to correspond to specific categories of data, and some groups might not have data for some of the categories, that doesn't work well. The two-parameter form of crosstab handles this case by providing an explicit list of the categories corresponding to the output columns.
	-- The first parameter is a SQL statement that produces the source set of data and returns one row_name column, one category column, and one value column, as well as possible extra columns (which are expected to be the same for all rows with the same row_name value) between the first and the last two columns previously mentioned.
	-- The second parameter is a SQL statement that produces a duplicates-free non-empty set of datas

	--crosstab_sql = 'SELECT * INTO '||pivottable||' FROM crosstab (''SELECT '||rowc||', '||sourcecolc||', string_agg('||cellc||','''','''') FROM '||sourcetablename||' GROUP BY '||rowc||','||sourcecolc||' ORDER BY '||rowc||','||sourcecolc||''', ''SELECT DISTINCT '||sourcecolc||' FROM  '||sourcetablename||' ORDER BY '||sourcecolc||''') AS '||pivottable||' ('||rowc||' '||rowctype||', '||columnlist||');'; -- actual names and types of the output columns, since the crosstab function is declared to return setof record.

	crosstab_sql = 'CREATE TABLE '||pivottable||' AS (SELECT * FROM crosstab (''SELECT '||rowc||', '||sourcecolc||', string_agg('||cellc||','''','''') FROM '||sourcetablename||' GROUP BY '||rowc||','||sourcecolc||' ORDER BY '||rowc||','||sourcecolc||''', ''SELECT DISTINCT '||sourcecolc||' FROM  '||sourcetablename||' ORDER BY '||sourcecolc||''') AS '||pivottable||' ('||rowc||' '||rowctype||', '||columnlist||'));';

EXECUTE crosstab_sql;

	--RAISE NOTICE 'crosstab_sql: %', crosstab_sql;
	RETURN crosstab_sql;

END;
$$ LANGUAGE plpgsql VOLATILE;
CREATE FUNCTION





/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/3-*Archives-pgSQL.sql






/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/3-dbCrea-Function-incrementdailycounterbyhourdiffMain-pgSQL.sql

CREATE OR REPLACE FUNCTION  incrementdailycounterbyhourdiff ()
RETURNS TRIGGER
AS $$
BEGIN
  UPDATE dailybalcount SET dbalance = CAST(dbalance+(NEW.hbalance-OLD.hbalance) AS DECIMAL) WHERE dcreationtime >= (SELECT MAX(dcreationtime) FROM dailybalcount);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/3-dbCrea-Function-incrementhourlycounterbychargedserviceMain-pgSQL.sql

CREATE OR REPLACE FUNCTION  incrementhourlycounterbychargedservice ()
RETURNS TRIGGER
AS $$
BEGIN
  UPDATE hourlybalcount SET hbalance = hbalance+(NEW.chargedunitprice*(1+vat_percentage)*NEW.quantity) WHERE hcreationtime >= (SELECT MAX(hcreationtime) FROM hourlybalcount);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/3-dbCrea-Function-incrementmonthlycounterbydaydiffMain-pgSQL.sql

CREATE OR REPLACE FUNCTION  incrementmonthlycounterbydaydiff ()
RETURNS TRIGGER
AS $$
BEGIN
  UPDATE monthlybalcount SET mbalance = mbalance+(NEW.dbalance-OLD.dbalance) WHERE mcreationtime >= (SELECT MAX(mcreationtime) FROM monthlybalcount);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/3-dbCrea-Function-incrementyearlycounterbymonthdiffMain-pgSQL.sql

CREATE OR REPLACE FUNCTION  incrementyearlycounterbymonthdiff ()
RETURNS TRIGGER
AS $$
BEGIN
  UPDATE yearlybalcount SET ybalance = ybalance+(NEW.mbalance-OLD.mbalance) WHERE ycreationtime >= (SELECT MAX(ycreationtime) FROM yearlybalcount);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/3-dbCrea-Function-restartdailybalanceMain-pgSQL.sql

CREATE OR REPLACE FUNCTION  restartdailybalance (restartyear SMALLINT, restartmonth SMALLINT, restartday SMALLINT)
RETURNS BOOLEAN
AS $$
  DECLARE previousyear SMALLINT;
  DECLARE previousmonth SMALLINT;
  DECLARE nowtimestamp TIMESTAMP;
  DECLARE oldbalance DECIMAL;
  DECLARE currentbalance DECIMAL;
  DECLARE restarthour SMALLINT;
BEGIN
  nowtimestamp = CURRENT_TIMESTAMP;
  oldbalance = 0.0;
  currentbalance = 0.0;
  IF restartmonth = 1 THEN
	previousyear = restartyear-1;
  ELSE
	previousyear = restartyear;
  END IF;
  IF restartday = 1 THEN
	previousmonth = restartmonth-1;
  ELSE
	previousmonth = restartmonth;
  END IF;
  SELECT dbalance INTO oldbalance FROM dailybalcount WHERE dyearlog = previousyear AND dmonthlog = previousmonth AND ddaylog = (restartday-1) AND hourlog = 0;
  IF oldbalance IS NULL THEN
	oldbalance = 0.0;
  END IF;
  SELECT balance INTO currentbalance FROM balancelog_archive WHERE yearlog = previousyear AND monthlog = previousmonth AND daylog = (restartday-1) AND hourlog = 0;
  IF currentbalance IS NULL THEN
	currentbalance=0.0;
  END IF;
  SELECT gen_upsert_BALANCELOG (hstore(ARRAY[['balance','('||oldbalance||' + '||currentbalance||')'],['yearlog',previousyear],['monthlog',previousmonth],['daylog',restartday-1],['hourlog','0']]));
  -- CREATE new counter (rz)
  INSERT INTO dailybalcount(dcreationtime, dyearlog, dmonthlog, ddaylog, dbalance) VALUES (nowtimestamp, restartyear, restartmonth, restartday, 0);
  --propagate restart
  SELECT hhourlog INTO restarthour FROM hourlybalcount WHERE hcreationtime >= (SELECT MAX(hcreationtime) FROM hourlybalcount);
  SELECT restarthourlybalance(restartyear, restartmonth, restartday, restarthour);
  RETURN TRUE;
EXCEPTION
  WHEN QUERY_CANCELED OR OTHERS THEN
	RETURN FALSE;
END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/3-dbCrea-Function-restarthourlybalanceMain-pgSQL.sql

CREATE OR REPLACE FUNCTION  restarthourlybalance (restartyear SMALLINT, restartmonth SMALLINT, restartday SMALLINT, restarthour SMALLINT)
RETURNS BOOLEAN
AS $$
  DECLARE previousyear SMALLINT;
  DECLARE previousmonth SMALLINT;
  DECLARE previousday SMALLINT;
  DECLARE nowtimestamp TIMESTAMP;
  DECLARE oldbalance DECIMAL;
  DECLARE currentbalance DECIMAL;
BEGIN
  nowtimestamp = CURRENT_TIMESTAMP;
  oldbalance = 0.0;
  currentbalance = 0.0;
  IF restartmonth = 1 THEN
	previousyear = restartyear-1;
  ELSE
	previousyear = restartyear;
  END IF;
  IF restartday = 1 THEN
	previousmonth = restartmonth-1;
  ELSE
	previousmonth = restartmonth;
  END IF;
  IF restarthour = 1 THEN
	previousday = previousday-1;
  ELSE
	previousday = previousday;
  END IF;
  SELECT hbalance INTO oldbalance FROM hourlybalcount WHERE hyearlog = previousyear AND hmonthlog = previousmonth AND hdaylog =  previousday AND hhourlog = (restarthour-1);
  IF oldbalance IS NULL THEN
	oldbalance = 0.0;
  END IF;
  SELECT balance INTO currentbalance FROM balancelog_archive WHERE yearlog = previousyear AND monthlog = previousmonth AND daylog =  previousday AND hourlog = (restarthour-1);
  IF currentbalance IS NULL THEN
	currentbalance=0.0;
  END IF;
  SELECT gen_upsert_BALANCELOG (hstore(ARRAY[['balance','('||oldbalance||' + '||currentbalance||')'],['yearlog',previousyear],['monthlog',previousmonth],['daylog',previousday],['hourlog',restarthour-1]]));

  -- CREATE new counter (rz)
  INSERT INTO hourlybalcount(hcreationtime, hyearlog, hmonthlog, hdaylog, hhourlog, hbalance) VALUES (nowtimestamp, restartyear, restartmonth, restartday, restarthour, 0.0);
  RETURN TRUE;
EXCEPTION
  WHEN QUERY_CANCELED OR OTHERS THEN
	RETURN FALSE;
END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/3-dbCrea-Function-restartmonthlybalanceMain-pgSQL.sql

CREATE OR REPLACE FUNCTION  restartmonthlybalance (restartyear SMALLINT, restartmonth SMALLINT)
RETURNS BOOLEAN
AS $$
  DECLARE previousyear SMALLINT;
  DECLARE nowtimestamp TIMESTAMP;
  DECLARE oldbalance DECIMAL;
  DECLARE currentbalance DECIMAL;
  DECLARE restartday SMALLINT;
BEGIN
  nowtimestamp = CURRENT_TIMESTAMP;
  oldbalance = 0.0;
  currentbalance = 0.0;
  IF restartmonth = 1 THEN
	previousyear = restartyear-1;
  ELSE
	previousyear = restartyear;
  END IF;
  SELECT mbalance INTO oldbalance FROM monthlybalcount WHERE myearlog = previousyear AND mmonthlog = (restartmonth-1) AND daylog = 0 AND hourlog = 0;
  IF oldbalance IS NULL THEN
	oldbalance = 0.0;
  END IF;
  SELECT balance INTO currentbalance FROM balancelog_archive WHERE yearlog = previousyear AND monthlog = (restartmonth-1) AND daylog = 0 AND hourlog = 0;
  IF currentbalance IS NULL THEN
	currentbalance=0.0;
  END IF;
  SELECT gen_upsert_BALANCELOG (hstore(ARRAY[['balance','('||oldbalance||' + '||currentbalance||')'],['yearlog',previousyear],['monthlog',restartmonth-1],['daylog','0'],['hourlog','0']]));
  -- CREATE new counter (rz)
  INSERT INTO monthlybalcount(mcreationtime, myearlog, mmonthlog, mbalance) VALUES (nowtimestamp, restartyear, restartmonth, 0.0);
  --propagate restart
  SELECT ddaylog INTO restartday FROM dailybalcount WHERE dcreationtime >= (SELECT MAX(dcreationtime) FROM dailybalcount);
  SELECT restartdailybalance(restartyear, restartmonth, restartday);
  RETURN TRUE;
EXCEPTION
  WHEN QUERY_CANCELED OR OTHERS THEN
	RETURN FALSE;
END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/3-dbCrea-Function-restartyearlybalanceMain-pgSQL.sql

CREATE OR REPLACE FUNCTION  restartyearlybalance ( restartyear SMALLINT )
RETURNS BOOLEAN
AS $$
  DECLARE nowtimestamp TIMESTAMP;
  DECLARE oldbalance DECIMAL;
  DECLARE currentbalance DECIMAL;
  DECLARE restartmonth SMALLINT;
BEGIN
  nowtimestamp = CURRENT_TIMESTAMP;
  oldbalance = 0.0;
  currentbalance = 0.0;
  SELECT ybalance INTO oldbalance FROM yearlybalcount WHERE yyearlog = (restartyear-1);
  IF oldbalance IS NULL THEN
	oldbalance = 0.0;
  END IF;
  SELECT balance INTO currentbalance FROM balancelog_archive WHERE yearlog = (restartyear-1) AND monthlog = 0 AND daylog = 0 AND hourlog = 0;
  IF currentbalance IS NULL THEN
	currentbalance=0.0;
  END IF;
  SELECT gen_upsert_BALANCELOG (hstore(ARRAY[['balance','('||oldbalance||' + '||currentbalance||')'],['yearlog',restartyear-1],['monthlog','0'],['daylog','0'],['hourlog','0']]));
  -- CREATE new counter (rz)
  INSERT INTO yearlybalcount(ycreationtime, yyearlog, ybalance) VALUES (nowtimestamp, restartyear, 0.0);
  --propagate restart
  SELECT mmonthlog INTO restartmonth FROM monthlybalcount WHERE mcreationtime >= (SELECT MAX(mcreationtime) FROM monthlybalcount);
  SELECT restartmonthlybalance(restartyear, restartmonth);
  RETURN TRUE;
EXCEPTION
  WHEN QUERY_CANCELED OR OTHERS THEN
	RETURN FALSE;
END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION


_______________________

k=4





/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/4-*Tous-pgSQL.sql






/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/4-*Archives-pgSQL.sql






/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/4-dbCrea-Trigger-dailybalancecounterMain-pgSQL.sql

CREATE TRIGGER tr_daylog AFTER UPDATE ON dailybalcount
FOR EACH ROW
WHEN ((NEW.dbalance IS NOT NULL) AND (NEW.dbalance > 0))
EXECUTE PROCEDURE incrementmonthlycounterbydaydiff();
CREATE TRIGGER


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/4-dbCrea-Trigger-hourlybalancecounterMain-pgSQL.sql

CREATE TRIGGER tr_hourlog AFTER UPDATE ON hourlybalcount
FOR EACH ROW
WHEN ((NEW.hbalance IS NOT NULL) AND (NEW.hbalance > 0))
EXECUTE PROCEDURE incrementdailycounterbyhourdiff();
CREATE TRIGGER


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/4-dbCrea-Trigger-monthlybalancecounterMain-pgSQL.sql

CREATE TRIGGER tr_monthlog AFTER UPDATE ON monthlybalcount
FOR EACH ROW
WHEN ((NEW.mbalance IS NOT NULL) AND (NEW.mbalance > 0))
EXECUTE PROCEDURE incrementyearlycounterbymonthdiff();
CREATE TRIGGER


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/4-dbCrea-Trigger-registerchargingMain-pgSQL.sql

CREATE TRIGGER tr_registercharging AFTER UPDATE ON chargedservices
FOR EACH ROW
WHEN ((NEW.quantity IS NOT NULL) AND (NEW.quantity > 0))
EXECUTE PROCEDURE incrementhourlycounterbychargedservice();
CREATE TRIGGER


_______________________

k=5





/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/5-*Tous-pgSQL.sql






/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/5-dbInitArchives-pgSQL.sql

SELECT genall_upsertID();
 genall_upsertid 
-----------------
 
(1 ligne)

SELECT gen_upsert('ADDRESSES', 'client_id=CAST(NEW.client_ID AS INTEGER), zipcode=NEW.zipcode, phone=NEW.phone,complementaryline=NEW.complementaryline', 'contact=NEW.contact AND street=NEW.street AND number=NEW.number AND city=NEW.city AND country=NEW.country', 'ID');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        gen_upsert                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION  genupsert_ADDRESSES(newinput hstore) RETURNS  TEXT AS $inner$ DECLARE returnVar TEXT;  BEGIN  WITH upsert AS ( UPDATE ADDRESSES SET client_id=CAST(newinput -> 'client_ID' AS INTEGER), zipcode=newinput -> 'zipcode', phone=newinput -> 'phone',complementaryline=newinput -> 'complementaryline'  WHERE contact=newinput -> 'contact' AND street=newinput -> 'street' AND number=newinput -> 'number' AND city=newinput -> 'city' AND country=newinput -> 'country'  RETURNING ADDRESSES.* )  INSERT INTO ADDRESSES (SELECT * FROM ADDRESSES WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE contact=b.contact AND street=b.street AND number=b.number AND city=b.city AND country=b.country)) ; SELECT ID INTO returnVar FROM ADDRESSES WHERE contact=newinput -> 'contact' AND street=newinput -> 'street' AND number=newinput -> 'number' AND city=newinput -> 'city' AND country=newinput -> 'country' ;  RAISE NOTICE 'WITH upsert AS ( UPDATE ADDRESSES SET client_id=CAST(newinput -> ''client_ID'' AS INTEGER), zipcode=newinput -> ''zipcode'', phone=newinput -> ''phone'',complementaryline=newinput -> ''complementaryline''  WHERE contact=newinput -> ''contact'' AND street=newinput -> ''street'' AND number=newinput -> ''number'' AND city=newinput -> ''city'' AND country=newinput -> ''country''  RETURNING ADDRESSES.* )  INSERT INTO ADDRESSES (SELECT * FROM ADDRESSES WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE contact=b.contact AND street=b.street AND number=b.number AND city=b.city AND country=b.country)) ; SELECT ID INTO returnVar FROM ADDRESSES WHERE contact=newinput -> ''contact'' AND street=newinput -> ''street'' AND number=newinput -> ''number'' AND city=newinput -> ''city'' AND country=newinput -> ''country'' ;';  RAISE NOTICE ' ==> %', returnVar; RETURN CAST(returnVar AS TEXT);  EXECUTE query; END; $inner$ LANGUAGE plpgsql; 
(1 ligne)

SELECT gen_upsert('GROUPS', 'CONTACT_ID=CAST(NEW.CONTACT_ID AS INTEGER)', 'NAME=NEW.NAME', 'ID');
                                                                                                                                                                                                                                                                                                                                                                                                                                                      gen_upsert                                                                                                                                                                                                                                                                                                                                                                                                                                                      
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION  genupsert_GROUPS(newinput hstore) RETURNS  TEXT AS $inner$ DECLARE returnVar TEXT;  BEGIN  WITH upsert AS ( UPDATE GROUPS SET CONTACT_ID=CAST(newinput -> 'CONTACT_ID' AS INTEGER) WHERE NAME=newinput -> 'NAME'  RETURNING GROUPS.* )  INSERT INTO GROUPS (SELECT * FROM GROUPS WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE NAME=b.NAME)) ; SELECT ID INTO returnVar FROM GROUPS WHERE NAME=newinput -> 'NAME' ;  RAISE NOTICE 'WITH upsert AS ( UPDATE GROUPS SET CONTACT_ID=CAST(newinput -> ''CONTACT_ID'' AS INTEGER) WHERE NAME=newinput -> ''NAME''  RETURNING GROUPS.* )  INSERT INTO GROUPS (SELECT * FROM GROUPS WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE NAME=b.NAME)) ; SELECT ID INTO returnVar FROM GROUPS WHERE NAME=newinput -> ''NAME'' ;';  RAISE NOTICE ' ==> %', returnVar; RETURN CAST(returnVar AS TEXT);  EXECUTE query; END; $inner$ LANGUAGE plpgsql; 
(1 ligne)

SELECT gen_upsert('BALANCELOG', 'balance=CAST(NEW.balance AS DECIMAL)', 'yearlog=CAST(NEW.yearlog AS SMALLINTEGER) AND monthlog=CAST(NEW.monthlog AS SMALLINTEGER) AND daylog=CAST(NEW.daylog AS SMALLINTEGER) AND hourlog=CAST(NEW.hourlog AS SMALLINTEGER)', 'BALANCE');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       gen_upsert                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION  genupsert_BALANCELOG(newinput hstore) RETURNS  TEXT AS $inner$ DECLARE returnVar TEXT;  BEGIN  WITH upsert AS ( UPDATE BALANCELOG SET balance=CAST(newinput -> 'balance' AS DECIMAL) WHERE yearlog=CAST(newinput -> 'yearlog' AS SMALLINTEGER) AND monthlog=CAST(newinput -> 'monthlog' AS SMALLINTEGER) AND daylog=CAST(newinput -> 'daylog' AS SMALLINTEGER) AND hourlog=CAST(newinput -> 'hourlog' AS SMALLINTEGER) RETURNING BALANCELOG.* )  INSERT INTO BALANCELOG (SELECT * FROM BALANCELOG WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE yearlog=CAST(b.yearlog AS SMALLINTEGER) AND monthlog=CAST(b.monthlog AS SMALLINTEGER) AND daylog=CAST(b.daylog AS SMALLINTEGER) AND hourlog=CAST(b.hourlog AS SMALLINTEGER))) ; SELECT BALANCE INTO returnVar FROM BALANCELOG WHERE yearlog=CAST(newinput -> 'yearlog' AS SMALLINTEGER) AND monthlog=CAST(newinput -> 'monthlog' AS SMALLINTEGER) AND daylog=CAST(newinput -> 'daylog' AS SMALLINTEGER) AND hourlog=CAST(newinput -> 'hourlog' AS SMALLINTEGER);  RAISE NOTICE 'WITH upsert AS ( UPDATE BALANCELOG SET balance=CAST(newinput -> ''balance'' AS DECIMAL) WHERE yearlog=CAST(newinput -> ''yearlog'' AS SMALLINTEGER) AND monthlog=CAST(newinput -> ''monthlog'' AS SMALLINTEGER) AND daylog=CAST(newinput -> ''daylog'' AS SMALLINTEGER) AND hourlog=CAST(newinput -> ''hourlog'' AS SMALLINTEGER) RETURNING BALANCELOG.* )  INSERT INTO BALANCELOG (SELECT * FROM BALANCELOG WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE yearlog=CAST(b.yearlog AS SMALLINTEGER) AND monthlog=CAST(b.monthlog AS SMALLINTEGER) AND daylog=CAST(b.daylog AS SMALLINTEGER) AND hourlog=CAST(b.hourlog AS SMALLINTEGER))) ; SELECT BALANCE INTO returnVar FROM BALANCELOG WHERE yearlog=CAST(newinput -> ''yearlog'' AS SMALLINTEGER) AND monthlog=CAST(newinput -> ''monthlog'' AS SMALLINTEGER) AND daylog=CAST(newinput -> ''daylog'' AS SMALLINTEGER) AND hourlog=CAST(newinput -> ''hourlog'' AS SMALLINTEGER);';  RAISE NOTICE ' ==> %', returnVar; RETURN CAST(returnVar AS TEXT);  EXECUTE query; END; $inner$ LANGUAGE plpgsql; 
(1 ligne)

SELECT gen_upsert('NATIONALITIES', 'COUNTRY=NEW.COUNTRY, LONGISOCODE=NEW.LONGISOCODE, ISOCODE=NEW.ISOCODE', 'CODE=CAST(NEW.CODE AS SMALLINTEGER)', 'ID');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              gen_upsert                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION  genupsert_NATIONALITIES(newinput hstore) RETURNS  TEXT AS $inner$ DECLARE returnVar TEXT;  BEGIN  WITH upsert AS ( UPDATE NATIONALITIES SET COUNTRY=newinput -> 'COUNTRY', LONGISOCODE=newinput -> 'LONGISOCODE', ISOCODE=newinput -> 'ISOCODE'  WHERE CODE=CAST(newinput -> 'CODE' AS SMALLINTEGER) RETURNING NATIONALITIES.* )  INSERT INTO NATIONALITIES (SELECT * FROM NATIONALITIES WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE CODE=CAST(b.CODE AS SMALLINTEGER))) ; SELECT ID INTO returnVar FROM NATIONALITIES WHERE CODE=CAST(newinput -> 'CODE' AS SMALLINTEGER);  RAISE NOTICE 'WITH upsert AS ( UPDATE NATIONALITIES SET COUNTRY=newinput -> ''COUNTRY'', LONGISOCODE=newinput -> ''LONGISOCODE'', ISOCODE=newinput -> ''ISOCODE''  WHERE CODE=CAST(newinput -> ''CODE'' AS SMALLINTEGER) RETURNING NATIONALITIES.* )  INSERT INTO NATIONALITIES (SELECT * FROM NATIONALITIES WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE CODE=CAST(b.CODE AS SMALLINTEGER))) ; SELECT ID INTO returnVar FROM NATIONALITIES WHERE CODE=CAST(newinput -> ''CODE'' AS SMALLINTEGER);';  RAISE NOTICE ' ==> %', returnVar; RETURN CAST(returnVar AS TEXT);  EXECUTE query; END; $inner$ LANGUAGE plpgsql; 
(1 ligne)

SELECT gen_upsertmult('CLIENTS', array['NAME=NEW.NAME, PHONE=NEW.PHONE, IDCARDSCAN=NEW.IDCARDSCAN, NATIONALITY_ID=CAST(NEW.NATIONALITY_ID AS INTEGER), HOMEADDRESS_ID=CAST(NEW.HOMEADDRESS_ID AS INTEGER), ISCURRENT=CAST(NEW.ISCURRENT AS BOOLEAN)','EMAIL=NEW.EMAIL, PHONE=NEW.PHONE, NATIONALITY_ID=CAST(NEW.NATIONALITY_ID AS INTEGER), HOMEADDRESS_ID=CAST(NEW.HOMEADDRESS_ID AS INTEGER),ISCURRENT=CAST(NEW.ISCURRENT AS BOOLEAN)', 'EMAIL=NEW.EMAIL, PHONE=NEW.PHONE, IDCARDSCAN=NEW.IDCARDSCAN, NATIONALITY_ID=CAST(NEW.NATIONALITY_ID AS INTEGER), ISCURRENT=CAST(NEW.ISCURRENT AS BOOLEAN)'], array['EMAIL=NEW.EMAIL','NAME=NEW.NAME AND IDCARDSCAN=NEW.IDCARDSCAN AND IDCARDSCAN IS NOT NULL','NAME=NEW.NAME AND HOMEADDRESS_ID=CAST(NEW.HOMEADDRESS_ID AS INTEGER) AND HOMEADDRESS_ID IS NOT NULL'], 'ID');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            gen_upsertmult                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION  genupsert_CLIENTS(newinput hstore) RETURNS  TEXT AS $inner$ DECLARE returnVar TEXT;  BEGIN   WITH  upsert1 AS ( UPDATE CLIENTS SET NAME=newinput -> 'NAME', PHONE=newinput -> 'PHONE', IDCARDSCAN=newinput -> 'IDCARDSCAN', NATIONALITY_ID=CAST(newinput -> 'NATIONALITY_ID' AS INTEGER), HOMEADDRESS_ID=CAST(newinput -> 'HOMEADDRESS_ID' AS INTEGER), ISCURRENT=CAST(newinput -> 'ISCURRENT' AS BOOLEAN) WHERE EMAIL=newinput -> 'EMAIL' RETURNING CLIENTS.* ),  upsert2 AS ( UPDATE CLIENTS SET EMAIL=newinput -> 'EMAIL', PHONE=newinput -> 'PHONE', NATIONALITY_ID=CAST(newinput -> 'NATIONALITY_ID' AS INTEGER), HOMEADDRESS_ID=CAST(newinput -> 'HOMEADDRESS_ID' AS INTEGER),ISCURRENT=CAST(newinput -> 'ISCURRENT' AS BOOLEAN) WHERE NAME=newinput -> 'NAME' AND IDCARDSCAN=newinput -> 'IDCARDSCAN' AND IDCARDSCAN IS NOT NULL RETURNING CLIENTS.* ),  upsert3 AS ( UPDATE CLIENTS SET EMAIL=newinput -> 'EMAIL', PHONE=newinput -> 'PHONE', IDCARDSCAN=newinput -> 'IDCARDSCAN', NATIONALITY_ID=CAST(newinput -> 'NATIONALITY_ID' AS INTEGER), ISCURRENT=CAST(newinput -> 'ISCURRENT' AS BOOLEAN) WHERE NAME=newinput -> 'NAME' AND HOMEADDRESS_ID=CAST(newinput -> 'HOMEADDRESS_ID' AS INTEGER) AND HOMEADDRESS_ID IS NOT NULL RETURNING CLIENTS.* ) INSERT INTO CLIENTS (SELECT * FROM CLIENTS WHERE NOT EXISTS (  SELECT 1 FROM  upsert1 b1 WHERE (EMAIL=b1.EMAIL) UNION ALL  SELECT 1 FROM  upsert2 b2 WHERE (NAME=b2.NAME AND IDCARDSCAN=b2.IDCARDSCAN AND IDCARDSCAN IS NOT NULL) UNION ALL  SELECT 1 FROM  upsert3 b3 WHERE (NAME=b3.NAME AND HOMEADDRESS_ID=CAST(b3.HOMEADDRESS_ID AS INTEGER) AND HOMEADDRESS_ID IS NOT NULL) )); SELECT ID INTO returnVar FROM CLIENTS WHERE  EMAIL=newinput -> 'EMAIL' OR  NAME=newinput -> 'NAME' AND IDCARDSCAN=newinput -> 'IDCARDSCAN' AND IDCARDSCAN IS NOT NULL OR  NAME=newinput -> 'NAME' AND HOMEADDRESS_ID=CAST(newinput -> 'HOMEADDRESS_ID' AS INTEGER) AND HOMEADDRESS_ID IS NOT NULL; RAISE NOTICE ' WITH  upsert1 AS ( UPDATE CLIENTS SET NAME=newinput -> ''NAME'', PHONE=newinput -> ''PHONE'', IDCARDSCAN=newinput -> ''IDCARDSCAN'', NATIONALITY_ID=CAST(newinput -> ''NATIONALITY_ID'' AS INTEGER), HOMEADDRESS_ID=CAST(newinput -> ''HOMEADDRESS_ID'' AS INTEGER), ISCURRENT=CAST(newinput -> ''ISCURRENT'' AS BOOLEAN) WHERE EMAIL=newinput -> ''EMAIL'' RETURNING CLIENTS.* ),  upsert2 AS ( UPDATE CLIENTS SET EMAIL=newinput -> ''EMAIL'', PHONE=newinput -> ''PHONE'', NATIONALITY_ID=CAST(newinput -> ''NATIONALITY_ID'' AS INTEGER), HOMEADDRESS_ID=CAST(newinput -> ''HOMEADDRESS_ID'' AS INTEGER),ISCURRENT=CAST(newinput -> ''ISCURRENT'' AS BOOLEAN) WHERE NAME=newinput -> ''NAME'' AND IDCARDSCAN=newinput -> ''IDCARDSCAN'' AND IDCARDSCAN IS NOT NULL RETURNING CLIENTS.* ),  upsert3 AS ( UPDATE CLIENTS SET EMAIL=newinput -> ''EMAIL'', PHONE=newinput -> ''PHONE'', IDCARDSCAN=newinput -> ''IDCARDSCAN'', NATIONALITY_ID=CAST(newinput -> ''NATIONALITY_ID'' AS INTEGER), ISCURRENT=CAST(newinput -> ''ISCURRENT'' AS BOOLEAN) WHERE NAME=newinput -> ''NAME'' AND HOMEADDRESS_ID=CAST(newinput -> ''HOMEADDRESS_ID'' AS INTEGER) AND HOMEADDRESS_ID IS NOT NULL RETURNING CLIENTS.* ) INSERT INTO CLIENTS (SELECT * FROM CLIENTS WHERE NOT EXISTS (  SELECT 1 FROM  upsert1 b1 WHERE (EMAIL=b1.EMAIL) UNION ALL  SELECT 1 FROM  upsert2 b2 WHERE (NAME=b2.NAME AND IDCARDSCAN=b2.IDCARDSCAN AND IDCARDSCAN IS NOT NULL) UNION ALL  SELECT 1 FROM  upsert3 b3 WHERE (NAME=b3.NAME AND HOMEADDRESS_ID=CAST(b3.HOMEADDRESS_ID AS INTEGER) AND HOMEADDRESS_ID IS NOT NULL) )); SELECT ID INTO returnVar FROM CLIENTS WHERE  EMAIL=newinput -> ''EMAIL'' OR  NAME=newinput -> ''NAME'' AND IDCARDSCAN=newinput -> ''IDCARDSCAN'' AND IDCARDSCAN IS NOT NULL OR  NAME=newinput -> ''NAME'' AND HOMEADDRESS_ID=CAST(newinput -> ''HOMEADDRESS_ID'' AS INTEGER) AND HOMEADDRESS_ID IS NOT NULL;'; RAISE NOTICE ' ==> %', returnVar; RETURN CAST(returnVar AS TEXT);  EXECUTE query; END; $inner$ LANGUAGE plpgsql; 
(1 ligne)

INSERT INTO NATIONALITIES --from http://www.lomag-man.org/iso3166paysmonde.xls
  (ID, COUNTRY, ISOCODE, LONGISOCODE, CODE)
  VALUES
(1, 'Afghanistan', 'AF', 'AFG', '004'),
(2, 'Albanie', 'AL', 'ALB', '008'),
(3, 'Algrie', 'DZ', 'DZA', '012'),
(4, 'Samoa orientales', 'AS', 'ASM', '016'),
(5, 'Andorre', 'AD', 'AND', '020'),
(6, 'Angola', 'AO', 'AGO', '024'),
(7, 'Anguilla', 'AI', 'AIA', '660'),
(8, 'Antarctique', 'AQ', 'ATA', '010'),
(9, 'Antigua-et-Barbuda', 'AG', 'ATG', '028'),
(10, 'Argentine', 'AR', 'ARG', '032'),
(11, 'Armnie', 'AM', 'ARM', '051'),
(12, 'Aruba', 'AW', 'ABW', '533'),
(13, 'Australie', 'AU', 'AUS', '036'),
(14, 'Autriche', 'AT', 'AUT', '040'),
(15, 'Azerbadjan', 'AZ', 'AZE', '031'),
(16, 'Bahamas', 'BS', 'BHS', '044'),
(17, 'Bahren', 'BH', 'BHR', '048'),
(18, 'Bangladesh', 'BD', 'BGD', '050'),
(19, 'Barbade', 'BB', 'BRB', '052'),
(20, 'Bilorussie', 'BY', 'BLR', '112'),
(21, 'Belgique', 'BE', 'BEL', '056'),
(22, 'Blize', 'BZ', 'BLZ', '084'),
(23, 'Bnin', 'BJ', 'BEN', '204'),
(24, 'Bermudes', 'BM', 'BMU', '060'),
(25, 'Bhoutan', 'BT', 'BTN', '064'),
(26, 'Bolivie', 'BO', 'BOL', '068'),
(27, 'Bosnie-Herzgovine', 'BA', 'BIH', '070'),
(28, 'Botswana', 'BW', 'BWA', '072'),
(29, 'Bouvet (le)', 'BV', 'BVT', '074'),
(30, 'Brsil', 'BR', 'BRA', '076'),
(31, 'Territoire britannique de l''Ocan Indien', 'IO', 'IOT', '086'),
(32, 'Brune', 'BN', 'BRN', '096'),
(33, 'Bulgarie', 'BG', 'BGR', '100'),
(34, 'Burkina Faso', 'BF', 'BFA', '854'),
(35, 'Burundi', 'BI', 'BDI', '108'),
(36, 'Cambodge', 'KH', 'KHM', '116'),
(37, 'Cameroun', 'CM', 'CMR', '120'),
(38, 'Canada', 'CA', 'CAN', '124'),
(39, 'Cap Vert', 'CV', 'CPV', '132'),
(40, 'Camans (les)', 'KY', 'CYM', '136'),
(41, 'Rpublique Centrafricaine', 'CF', 'CAF', '140'),
(42, 'Tchad', 'TD', 'TCD', '148'),
(43, 'Chili', 'CL', 'CHL', '152'),
(44, 'Chine', 'CN', 'CHN', '156'),
(45, 'Christmas (le)', 'CX', 'CXR', '162'),
(46, 'Cocos / Keeling (les)', 'CC', 'CCK', '166'),
(47, 'Colombie', 'CO', 'COL', '170'),
(48, 'Comores', 'KM', 'COM', '174'),
(49, 'Congo', 'CG', 'COG', '178'),
(50, 'Rpublique Dmocratique du Congo', 'CD', 'COD', '180'),
(51, 'Cook (les)', 'CK', 'COK', '184'),
(52, 'Costa Rica', 'CR', 'CRI', '188'),
(53, 'Cte D''Ivoire', 'CI', 'CIV', '384'),
(54, 'Croatie', 'HR', 'HRV', '191'),
(55, 'Cuba', 'CU', 'CUB', '192'),
(56, 'Chypre', 'CY', 'CYP', '196'),
(57, 'Rpublique Tchque', 'CZ', 'CZE', '203'),
(58, 'Danemark', 'DK', 'DNK', '208'),
(59, 'Djibouti', 'DJ', 'DJI', '262'),
(60, 'Dominique', 'DM', 'DMA', '212'),
(61, 'Rpublique Dominicaine', 'DO', 'DOM', '214'),
(62, 'Timor-Oriental', 'TP', 'TMP', '626'),
(63, 'Equateur', 'EC', 'ECU', '218'),
(64, 'Egypte', 'EG', 'EGY', '818'),
(65, 'Salvador', 'SV', 'SLV', '222'),
(66, 'Guine Equatoriale', 'GQ', 'GNQ', '226'),
(67, 'Erythre', 'ER', 'ERI', '232'),
(68, 'Estonie', 'EE', 'EST', '233'),
(69, 'Ethiopie', 'ET', 'ETH', '231'),
(70, 'Falkland / Malouines (les)', 'FK', 'FLK', '238'),
(71, 'Fro (les)', 'FO', 'FRO', '234'),
(72, 'Fiji', 'FJ', 'FJI', '242'),
(73, 'Finlande', 'FI', 'FIN', '246'),
(74, 'France', 'FR', 'FRA', '250'),
(75, 'France mtropolitaine', 'FX', 'FXX', '249'),
(76, 'Guyane franaise', 'GF', 'GUF', '254'),
(77, 'Polynsie franaise', 'PF', 'PYF', '258'),
(78, 'Territoires Antarctiques franais', 'TF', 'ATF', '260'),
(79, 'Gabon', 'GA', 'GAB', '266'),
(80, 'Gambie', 'GM', 'GMB', '270'),
(81, 'Gorgie', 'GE', 'GEO', '268'),
(82, 'Allemagne', 'DE', 'DEU', '276'),
(83, 'Ghana', 'GH', 'GHA', '288'),
(84, 'Gibraltar', 'GI', 'GIB', '292'),
(85, 'Grce', 'GR', 'GRC', '300'),
(86, 'Gronland', 'GL', 'GRL', '304'),
(87, 'Grenade', 'GD', 'GRD', '308'),
(88, 'Guadeloupe', 'GP', 'GLP', '312'),
(89, 'Guam', 'GU', 'GUM', '316'),
(90, 'Guatemala', 'GT', 'GTM', '320'),
(91, 'Guine', 'GN', 'GIN', '324'),
(92, 'Guine-Bissau', 'GW', 'GNB', '624'),
(93, 'Guyana', 'GY', 'GUY', '328'),
(94, 'Hati', 'HT', 'HTI', '332'),
(95, 'Territoire des les Heard et McDonald', 'HM', 'HMD', '334'),
(96, 'Saint-Sige (Vatican)', 'VA', 'VAT', '336'),
(97, 'Honduras', 'HN', 'HND', '340'),
(98, 'Hong Kong', 'HK', 'HKG', '344'),
(99, 'Hongrie', 'HU', 'HUN', '348'),
(100, 'Islande', 'IS', 'ISL', '352'),
(101, 'Inde', 'IN', 'IND', '356'),
(102, 'Indonsie', 'ID', 'IDN', '360'),
(103, 'Iran (Rpublique islamique d'')', 'IR', 'IRN', '364'),
(104, 'Irak', 'IQ', 'IRQ', '368'),
(105, 'Irlande', 'IE', 'IRL', '372'),
(106, 'Isral', 'IL', 'ISR', '376'),
(107, 'Italie', 'IT', 'ITA', '380'),
(108, 'Jamaque', 'JM', 'JAM', '388'),
(109, 'Japon', 'JP', 'JPN', '392'),
(110, 'Jordanie', 'JO', 'JOR', '400'),
(111, 'Kazakstan', 'KZ', 'KAZ', '398'),
(112, 'Kenya', 'KE', 'KEN', '404'),
(113, 'Kiribati', 'KI', 'KIR', '296'),
(114, 'Core (Rpublique populaire dmocratique de)', 'KP', 'PRK', '408'),
(115, 'Core (Rpublique dmocratique de)', 'KR', 'KOR', '410'),
(116, 'Kowet', 'KW', 'KWT', '414'),
(117, 'Kyrgyzstan', 'KG', 'KGZ', '417'),
(118, 'Laos (Rpublique populaire dmocratique du)', 'LA', 'LAO', '418'),
(119, 'Lettonie', 'LV', 'LVA', '428'),
(120, 'Liban', 'LB', 'LBN', '422'),
(121, 'Lesotho', 'LS', 'LSO', '426'),
(122, 'Libria', 'LR', 'LBR', '430'),
(123, 'Libye (Jamahiriya Arabe Libyenne)', 'LY', 'LBY', '434'),
(124, 'Liechtenstein', 'LI', 'LIE', '438'),
(125, 'Lithuanie', 'LT', 'LTU', '440'),
(126, 'Luxembourg', 'LU', 'LUX', '442'),
(127, 'Macau', 'MO', 'MAC', '446'),
(128, 'Macdoine (ancienne Rpublique yougoslave de)', 'MK', 'MKD', '807'),
(129, 'Madagascar', 'MG', 'MDG', '450'),
(130, 'Malawi', 'MW', 'MWI', '454'),
(131, 'Malaysie', 'MY', 'MYS', '458'),
(132, 'Maldives', 'MV', 'MDV', '462'),
(133, 'Mali', 'ML', 'MLI', '466'),
(134, 'Malte', 'MT', 'MLT', '470'),
(135, 'Marshall (les)', 'MH', 'MHL', '584'),
(136, 'Martinique', 'MQ', 'MTQ', '474'),
(137, 'Mauritanie', 'MR', 'MRT', '478'),
(138, 'Maurice', 'MU', 'MUS', '480'),
(139, 'Mayotte', 'YT', 'MYT', '175'),
(140, 'Mexique', 'MX', 'MEX', '484'),
(141, 'Micronsie (Etats fdrs de)', 'FM', 'FSM', '583'),
(142, 'Moldavie', 'MD', 'MDA', '498'),
(143, 'Monaco', 'MC', 'MCO', '492'),
(144, 'Mongolie', 'MN', 'MNG', '496'),
(145, 'Montserrat', 'MS', 'MSR', '500'),
(146, 'Maroc', 'MA', 'MAR', '504'),
(147, 'Mozambique', 'MZ', 'MOZ', '508'),
(148, 'Myanmar', 'MM', 'MMR', '104'),
(149, 'Namibie', 'NA', 'NAM', '516'),
(150, 'Nauru', 'NR', 'NRU', '520'),
(151, 'Npal', 'NP', 'NPL', '524'),
(152, 'Pays-Bas', 'NL', 'NLD', '528'),
(153, 'Antilles nerlandaises', 'AN', 'ANT', '530'),
(154, 'Nouvelle-Caldonie', 'NC', 'NCL', '540'),
(155, 'Nouvelle-Zlande', 'NZ', 'NZL', '554'),
(156, 'Nicaragua', 'NI', 'NIC', '558'),
(157, 'Niger', 'NE', 'NER', '562'),
(158, 'Nigria', 'NG', 'NGA', '566'),
(159, 'Niue', 'NU', 'NIU', '570'),
(160, 'Norfolk (le)', 'NF', 'NFK', '574'),
(161, 'Mariannes (les)', 'MP', 'MNP', '580'),
(162, 'Norvge', 'NO', 'NOR', '578'),
(163, 'Oman', 'OM', 'OMN', '512'),
(164, 'Pakistan', 'PK', 'PAK', '586'),
(165, 'Palau', 'PW', 'PLW', '585'),
(166, 'Panama', 'PA', 'PAN', '591'),
(167, 'Papouasie Nouvelle-Guine', 'PG', 'PNG', '598'),
(168, 'Paraguay', 'PY', 'PRY', '600'),
(169, 'Prou', 'PE', 'PER', '604'),
(170, 'Philippines', 'PH', 'PHL', '608'),
(171, 'Pitcarn', 'PN', 'PCN', '612'),
(172, 'Pologne', 'PL', 'POL', '616'),
(173, 'Portugal', 'PT', 'PRT', '620'),
(174, 'Porto Rico', 'PR', 'PRI', '630'),
(175, 'Quatar', 'QA', 'QAT', '634'),
(176, 'Runion', 'RE', 'REU', '638'),
(177, 'Romania', 'RO', 'ROM', '642'),
(178, 'Russie (Fdration de)', 'RU', 'RUS', '643'),
(179, 'Rwanda', 'RW', 'RWA', '646'),
(180, 'Saint Kitts et Nevis', 'KN', 'KNA', '659'),
(181, 'Sainte Lucie', 'LC', 'LCA', '662'),
(182, 'Saint Vincent et Grenadines', 'VC', 'VCT', '670'),
(183, 'Samoa', 'WS', 'WSM', '882'),
(184, 'San Marin', 'SM', 'SMR', '674'),
(185, 'Sao Tom et Principe', 'ST', 'STP', '678'),
(186, 'Arabie Saoudite', 'SA', 'SAU', '682'),
(187, 'Sngal', 'SN', 'SEN', '686'),
(188, 'Seychelles', 'SC', 'SYC', '690'),
(189, 'Sierra Lone', 'SL', 'SLE', '694'),
(190, 'Singapour', 'SG', 'SGP', '702'),
(191, 'Slovaquie', 'SK', 'SVK', '703'),
(192, 'Slovnie', 'SI', 'SVN', '705'),
(193, 'Salomon (les)', 'SB', 'SLB', '090'),
(194, 'Somalie', 'SO', 'SOM', '706'),
(195, 'Afrique du Sud', 'ZA', 'ZAF', '710'),
(196, 'Gorgie du Sud et les Sandwich du Sud', 'GS', 'SGS', '239'),
(197, 'Espagne', 'ES', 'ESP', '724'),
(198, 'Sri Lanka', 'LK', 'LKA', '144'),
(199, 'Ste Hlne', 'SH', 'SHN', '654'),
(200, 'St. Pierre et Miquelon', 'PM', 'SPM', '666'),
(201, 'Soudan', 'SD', 'SDN', '736'),
(202, 'Surinam', 'SR', 'SUR', '740'),
(203, 'Svalbard et Jan Mayen (les)', 'SJ', 'SJM', '744'),
(204, 'Swaziland', 'SZ', 'SWZ', '748'),
(205, 'Sude', 'SE', 'SWE', '752'),
(206, 'Suisse', 'CH', 'CHE', '756'),
(207, 'Syrie (Rpublique arabe syrienne)', 'SY', 'SYR', '760'),
(208, 'Tawan', 'TW', 'TWN', '158'),
(209, 'Tadjikistan', 'TJ', 'TJK', '762'),
(210, 'Tanzanie', 'TZ', 'TZA', '834'),
(211, 'Thalande', 'TH', 'THA', '764'),
(212, 'Togo', 'TG', 'TGO', '768'),
(213, 'Tokelau', 'TK', 'TKL', '772'),
(214, 'Tonga', 'TO', 'TON', '776'),
(215, 'Trinidad et Tobago', 'TT', 'TTO', '780'),
(216, 'Tunisie', 'TN', 'TUN', '788'),
(217, 'Turquie', 'TR', 'TUR', '792'),
(218, 'Turkmnistan', 'TM', 'TKM', '795'),
(219, 'Turks et Caicos (les)', 'TC', 'TCA', '796'),
(220, 'Tuvalu', 'TV', 'TUV', '798'),
(221, 'Ouganda', 'UG', 'UGA', '800'),
(222, 'Ukraine', 'UA', 'UKR', '804'),
(223, 'Emirats Arabes Unis', 'AE', 'ARE', '784'),
(224, 'Royaume-Uni', 'GB', 'GBR', '826'),
(225, 'Etats-Unis d''Amrique', 'US', 'USA', '840'),
(226, 'Territoires non incorpors des tats-Unis', 'UM', 'UMI', '581'),
(227, 'Uruguay', 'UY', 'URY', '858'),
(228, 'Ouzbkistan', 'UZ', 'UZB', '860'),
(229, 'Vanuatu', 'VU', 'VUT', '548'),
(230, 'Vnzuela', 'VE', 'VEN', '862'),
(231, 'Vietnam', 'VN', 'VNM', '704'),
(232, 'Vierges du Royaume-Uni (les)', 'VG', 'VGB', '092'),
(233, 'Vierges des tats-Unis (les)', 'VI', 'VIR', '850'),
(234, 'Wallis et Futuna (les)', 'WF', 'WLF', '876'),
(235, 'Sahara Occidental', 'EH', 'ESH', '732'),
(236, 'Yemen', 'YE', 'YEM', '887'),
(237, 'Yougoslavie', 'YU', 'YUG', '891'),
(238, 'Zambie', 'ZM', 'ZMB', '894'),
(239, 'Zimbabwe', 'ZW', 'ZWE', '716');
INSERT 0 239





/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/5-dbInitMain-pgSQL.sql

SELECT genall_upsertID();
 genall_upsertid 
-----------------
 
(1 ligne)

SELECT gen_upsert('BILLINGSTYPES', 'NBBILLS=CAST(NEW.NBBILLS AS SMALLINT)', 'LABEL=NEW.LABEL', 'ID');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             gen_upsert                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION  genupsert_BILLINGSTYPES(newinput hstore) RETURNS  TEXT AS $inner$ DECLARE returnVar TEXT;  BEGIN  WITH upsert AS ( UPDATE BILLINGSTYPES SET NBBILLS=CAST(newinput -> 'NBBILLS' AS SMALLINT) WHERE LABEL=newinput -> 'LABEL'  RETURNING BILLINGSTYPES.* )  INSERT INTO BILLINGSTYPES (SELECT * FROM BILLINGSTYPES WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE LABEL=b.LABEL)) ; SELECT ID INTO returnVar FROM BILLINGSTYPES WHERE LABEL=newinput -> 'LABEL' ;  RAISE NOTICE 'WITH upsert AS ( UPDATE BILLINGSTYPES SET NBBILLS=CAST(newinput -> ''NBBILLS'' AS SMALLINT) WHERE LABEL=newinput -> ''LABEL''  RETURNING BILLINGSTYPES.* )  INSERT INTO BILLINGSTYPES (SELECT * FROM BILLINGSTYPES WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE LABEL=b.LABEL)) ; SELECT ID INTO returnVar FROM BILLINGSTYPES WHERE LABEL=newinput -> ''LABEL'' ;';  RAISE NOTICE ' ==> %', returnVar; RETURN CAST(returnVar AS TEXT);  EXECUTE query; END; $inner$ LANGUAGE plpgsql; 
(1 ligne)

SELECT gen_upsert('BILLS', 'BILLTYPE_ID=CAST(NEW.BILLTYPE_ID AS INTEGER), NOTE=NEW.NOTE', 'BILLING_ID=CAST(NEW.BILLING_ID AS INTEGER) AND BILLINGBILLID=CAST(NEW.BILLINGBILLID AS INTEGER)', 'ID');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     gen_upsert                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION  genupsert_BILLS(newinput hstore) RETURNS  TEXT AS $inner$ DECLARE returnVar TEXT;  BEGIN  WITH upsert AS ( UPDATE BILLS SET BILLTYPE_ID=CAST(newinput -> 'BILLTYPE_ID' AS INTEGER), NOTE=newinput -> 'NOTE'  WHERE BILLING_ID=CAST(newinput -> 'BILLING_ID' AS INTEGER) AND BILLINGBILLID=CAST(newinput -> 'BILLINGBILLID' AS INTEGER) RETURNING BILLS.* )  INSERT INTO BILLS (SELECT * FROM BILLS WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE BILLING_ID=CAST(b.BILLING_ID AS INTEGER) AND BILLINGBILLID=CAST(b.BILLINGBILLID AS INTEGER))) ; SELECT ID INTO returnVar FROM BILLS WHERE BILLING_ID=CAST(newinput -> 'BILLING_ID' AS INTEGER) AND BILLINGBILLID=CAST(newinput -> 'BILLINGBILLID' AS INTEGER);  RAISE NOTICE 'WITH upsert AS ( UPDATE BILLS SET BILLTYPE_ID=CAST(newinput -> ''BILLTYPE_ID'' AS INTEGER), NOTE=newinput -> ''NOTE''  WHERE BILLING_ID=CAST(newinput -> ''BILLING_ID'' AS INTEGER) AND BILLINGBILLID=CAST(newinput -> ''BILLINGBILLID'' AS INTEGER) RETURNING BILLS.* )  INSERT INTO BILLS (SELECT * FROM BILLS WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE BILLING_ID=CAST(b.BILLING_ID AS INTEGER) AND BILLINGBILLID=CAST(b.BILLINGBILLID AS INTEGER))) ; SELECT ID INTO returnVar FROM BILLS WHERE BILLING_ID=CAST(newinput -> ''BILLING_ID'' AS INTEGER) AND BILLINGBILLID=CAST(newinput -> ''BILLINGBILLID'' AS INTEGER);';  RAISE NOTICE ' ==> %', returnVar; RETURN CAST(returnVar AS TEXT);  EXECUTE query; END; $inner$ LANGUAGE plpgsql; 
(1 ligne)

SELECT gen_upsert('TRAINING_BILLS', 'BILLTYPE_ID=CAST(NEW.BILLTYPE_ID AS INTEGER), NOTE=NEW.NOTE', 'BILLING_ID=CAST(NEW.BILLING_ID AS INTEGER) AND BILLINGBILLID=CAST(NEW.BILLINGBILLID AS INTEGER)', 'ID');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       gen_upsert                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION  genupsert_TRAINING_BILLS(newinput hstore) RETURNS  TEXT AS $inner$ DECLARE returnVar TEXT;  BEGIN  WITH upsert AS ( UPDATE TRAINING_BILLS SET BILLTYPE_ID=CAST(newinput -> 'BILLTYPE_ID' AS INTEGER), NOTE=newinput -> 'NOTE'  WHERE BILLING_ID=CAST(newinput -> 'BILLING_ID' AS INTEGER) AND BILLINGBILLID=CAST(newinput -> 'BILLINGBILLID' AS INTEGER) RETURNING TRAINING_BILLS.* )  INSERT INTO TRAINING_BILLS (SELECT * FROM TRAINING_BILLS WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE BILLING_ID=CAST(b.BILLING_ID AS INTEGER) AND BILLINGBILLID=CAST(b.BILLINGBILLID AS INTEGER))) ; SELECT ID INTO returnVar FROM TRAINING_BILLS WHERE BILLING_ID=CAST(newinput -> 'BILLING_ID' AS INTEGER) AND BILLINGBILLID=CAST(newinput -> 'BILLINGBILLID' AS INTEGER);  RAISE NOTICE 'WITH upsert AS ( UPDATE TRAINING_BILLS SET BILLTYPE_ID=CAST(newinput -> ''BILLTYPE_ID'' AS INTEGER), NOTE=newinput -> ''NOTE''  WHERE BILLING_ID=CAST(newinput -> ''BILLING_ID'' AS INTEGER) AND BILLINGBILLID=CAST(newinput -> ''BILLINGBILLID'' AS INTEGER) RETURNING TRAINING_BILLS.* )  INSERT INTO TRAINING_BILLS (SELECT * FROM TRAINING_BILLS WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE BILLING_ID=CAST(b.BILLING_ID AS INTEGER) AND BILLINGBILLID=CAST(b.BILLINGBILLID AS INTEGER))) ; SELECT ID INTO returnVar FROM TRAINING_BILLS WHERE BILLING_ID=CAST(newinput -> ''BILLING_ID'' AS INTEGER) AND BILLINGBILLID=CAST(newinput -> ''BILLINGBILLID'' AS INTEGER);';  RAISE NOTICE ' ==> %', returnVar; RETURN CAST(returnVar AS TEXT);  EXECUTE query; END; $inner$ LANGUAGE plpgsql; 
(1 ligne)

SELECT gen_upsert('CHARGEDSERVICES', 'INVOICINGDATE=CAST(NEW.INVOICINGDATE AS DATE),QUANTITY=CAST(NEW.QUANTITY AS SMALLINTEGER), CHARGEDUNITPRICE=CAST(NEW.CHARGEDUNITPRICE AS DECIMAL), VAT_PERCENTAGE=CAST(NEW.VAT_PERCENTAGE AS DECIMAL), ISPRINTED=CAST(NEW.ISPRINTED AS BOOLEAN), ISPAYED=CAST(NEW.ISPAYED AS BOOLEAN), PAIEMENTDATE=CAST(NEW.PAIEMENTDATE AS DATE)', 'SERVICE_ID=CAST(NEW.SERVICE_ID AS INTEGER) AND BILL_ID=CAST(NEW.BILL_ID AS INTEGER)', 'BILL_ID');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          gen_upsert                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION  genupsert_CHARGEDSERVICES(newinput hstore) RETURNS  TEXT AS $inner$ DECLARE returnVar TEXT;  BEGIN  WITH upsert AS ( UPDATE CHARGEDSERVICES SET INVOICINGDATE=CAST(newinput -> 'INVOICINGDATE' AS DATE),QUANTITY=CAST(newinput -> 'QUANTITY' AS SMALLINTEGER), CHARGEDUNITPRICE=CAST(newinput -> 'CHARGEDUNITPRICE' AS DECIMAL), VAT_PERCENTAGE=CAST(newinput -> 'VAT_PERCENTAGE' AS DECIMAL), ISPRINTED=CAST(newinput -> 'ISPRINTED' AS BOOLEAN), ISPAYED=CAST(newinput -> 'ISPAYED' AS BOOLEAN), PAIEMENTDATE=CAST(newinput -> 'PAIEMENTDATE' AS DATE) WHERE SERVICE_ID=CAST(newinput -> 'SERVICE_ID' AS INTEGER) AND BILL_ID=CAST(newinput -> 'BILL_ID' AS INTEGER) RETURNING CHARGEDSERVICES.* )  INSERT INTO CHARGEDSERVICES (SELECT * FROM CHARGEDSERVICES WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE SERVICE_ID=CAST(b.SERVICE_ID AS INTEGER) AND BILL_ID=CAST(b.BILL_ID AS INTEGER))) ; SELECT BILL_ID INTO returnVar FROM CHARGEDSERVICES WHERE SERVICE_ID=CAST(newinput -> 'SERVICE_ID' AS INTEGER) AND BILL_ID=CAST(newinput -> 'BILL_ID' AS INTEGER);  RAISE NOTICE 'WITH upsert AS ( UPDATE CHARGEDSERVICES SET INVOICINGDATE=CAST(newinput -> ''INVOICINGDATE'' AS DATE),QUANTITY=CAST(newinput -> ''QUANTITY'' AS SMALLINTEGER), CHARGEDUNITPRICE=CAST(newinput -> ''CHARGEDUNITPRICE'' AS DECIMAL), VAT_PERCENTAGE=CAST(newinput -> ''VAT_PERCENTAGE'' AS DECIMAL), ISPRINTED=CAST(newinput -> ''ISPRINTED'' AS BOOLEAN), ISPAYED=CAST(newinput -> ''ISPAYED'' AS BOOLEAN), PAIEMENTDATE=CAST(newinput -> ''PAIEMENTDATE'' AS DATE) WHERE SERVICE_ID=CAST(newinput -> ''SERVICE_ID'' AS INTEGER) AND BILL_ID=CAST(newinput -> ''BILL_ID'' AS INTEGER) RETURNING CHARGEDSERVICES.* )  INSERT INTO CHARGEDSERVICES (SELECT * FROM CHARGEDSERVICES WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE SERVICE_ID=CAST(b.SERVICE_ID AS INTEGER) AND BILL_ID=CAST(b.BILL_ID AS INTEGER))) ; SELECT BILL_ID INTO returnVar FROM CHARGEDSERVICES WHERE SERVICE_ID=CAST(newinput -> ''SERVICE_ID'' AS INTEGER) AND BILL_ID=CAST(newinput -> ''BILL_ID'' AS INTEGER);';  RAISE NOTICE ' ==> %', returnVar; RETURN CAST(returnVar AS TEXT);  EXECUTE query; END; $inner$ LANGUAGE plpgsql; 
(1 ligne)

SELECT gen_upsert('TRAINING_CHARGEDSERVICES', 'INVOICINGDATE=CAST(NEW.INVOICINGDATE AS DATE),QUANTITY=CAST(NEW.QUANTITY AS SMALLINTEGER), CHARGEDUNITPRICE=CAST(NEW.CHARGEDUNITPRICE AS DECIMAL), VAT_PERCENTAGE=CAST(NEW.VAT_PERCENTAGE AS DECIMAL), ISPRINTED=CAST(NEW.ISPRINTED AS BOOLEAN), ISPAYED=CAST(NEW.ISPAYED AS BOOLEAN), PAIEMENTDATE=CAST(NEW.PAIEMENTDATE AS DATE)', 'SERVICE_ID=CAST(NEW.SERVICE_ID AS INTEGER) AND BILL_ID=CAST(NEW.BILL_ID AS INTEGER)', 'BILL_ID');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            gen_upsert                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION  genupsert_TRAINING_CHARGEDSERVICES(newinput hstore) RETURNS  TEXT AS $inner$ DECLARE returnVar TEXT;  BEGIN  WITH upsert AS ( UPDATE TRAINING_CHARGEDSERVICES SET INVOICINGDATE=CAST(newinput -> 'INVOICINGDATE' AS DATE),QUANTITY=CAST(newinput -> 'QUANTITY' AS SMALLINTEGER), CHARGEDUNITPRICE=CAST(newinput -> 'CHARGEDUNITPRICE' AS DECIMAL), VAT_PERCENTAGE=CAST(newinput -> 'VAT_PERCENTAGE' AS DECIMAL), ISPRINTED=CAST(newinput -> 'ISPRINTED' AS BOOLEAN), ISPAYED=CAST(newinput -> 'ISPAYED' AS BOOLEAN), PAIEMENTDATE=CAST(newinput -> 'PAIEMENTDATE' AS DATE) WHERE SERVICE_ID=CAST(newinput -> 'SERVICE_ID' AS INTEGER) AND BILL_ID=CAST(newinput -> 'BILL_ID' AS INTEGER) RETURNING TRAINING_CHARGEDSERVICES.* )  INSERT INTO TRAINING_CHARGEDSERVICES (SELECT * FROM TRAINING_CHARGEDSERVICES WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE SERVICE_ID=CAST(b.SERVICE_ID AS INTEGER) AND BILL_ID=CAST(b.BILL_ID AS INTEGER))) ; SELECT BILL_ID INTO returnVar FROM TRAINING_CHARGEDSERVICES WHERE SERVICE_ID=CAST(newinput -> 'SERVICE_ID' AS INTEGER) AND BILL_ID=CAST(newinput -> 'BILL_ID' AS INTEGER);  RAISE NOTICE 'WITH upsert AS ( UPDATE TRAINING_CHARGEDSERVICES SET INVOICINGDATE=CAST(newinput -> ''INVOICINGDATE'' AS DATE),QUANTITY=CAST(newinput -> ''QUANTITY'' AS SMALLINTEGER), CHARGEDUNITPRICE=CAST(newinput -> ''CHARGEDUNITPRICE'' AS DECIMAL), VAT_PERCENTAGE=CAST(newinput -> ''VAT_PERCENTAGE'' AS DECIMAL), ISPRINTED=CAST(newinput -> ''ISPRINTED'' AS BOOLEAN), ISPAYED=CAST(newinput -> ''ISPAYED'' AS BOOLEAN), PAIEMENTDATE=CAST(newinput -> ''PAIEMENTDATE'' AS DATE) WHERE SERVICE_ID=CAST(newinput -> ''SERVICE_ID'' AS INTEGER) AND BILL_ID=CAST(newinput -> ''BILL_ID'' AS INTEGER) RETURNING TRAINING_CHARGEDSERVICES.* )  INSERT INTO TRAINING_CHARGEDSERVICES (SELECT * FROM TRAINING_CHARGEDSERVICES WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE SERVICE_ID=CAST(b.SERVICE_ID AS INTEGER) AND BILL_ID=CAST(b.BILL_ID AS INTEGER))) ; SELECT BILL_ID INTO returnVar FROM TRAINING_CHARGEDSERVICES WHERE SERVICE_ID=CAST(newinput -> ''SERVICE_ID'' AS INTEGER) AND BILL_ID=CAST(newinput -> ''BILL_ID'' AS INTEGER);';  RAISE NOTICE ' ==> %', returnVar; RETURN CAST(returnVar AS TEXT);  EXECUTE query; END; $inner$ LANGUAGE plpgsql; 
(1 ligne)

SELECT gen_upsertmult('REPORTSTYPES', array['GENERATIONQUERY=NEW.GENERATIONQUERY','LABEL=NEW.LABEL'], array['LABEL=NEW.LABEL','GENERATIONQUERY=NEW.GENERATIONQUERY'], 'LABEL');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      gen_upsertmult                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION  genupsert_REPORTSTYPES(newinput hstore) RETURNS  TEXT AS $inner$ DECLARE returnVar TEXT;  BEGIN   WITH  upsert1 AS ( UPDATE REPORTSTYPES SET GENERATIONQUERY=newinput -> 'GENERATIONQUERY'  WHERE LABEL=newinput -> 'LABEL' RETURNING REPORTSTYPES.* ),  upsert2 AS ( UPDATE REPORTSTYPES SET LABEL=newinput -> 'LABEL'  WHERE GENERATIONQUERY=newinput -> 'GENERATIONQUERY' RETURNING REPORTSTYPES.* ) INSERT INTO REPORTSTYPES (SELECT * FROM REPORTSTYPES WHERE NOT EXISTS (  SELECT 1 FROM  upsert1 b1 WHERE (LABEL=b1.LABEL) UNION ALL  SELECT 1 FROM  upsert2 b2 WHERE (GENERATIONQUERY=b2.GENERATIONQUERY) )); SELECT LABEL INTO returnVar FROM REPORTSTYPES WHERE  LABEL=newinput -> 'LABEL' OR  GENERATIONQUERY=newinput -> 'GENERATIONQUERY'; RAISE NOTICE ' WITH  upsert1 AS ( UPDATE REPORTSTYPES SET GENERATIONQUERY=newinput -> ''GENERATIONQUERY''  WHERE LABEL=newinput -> ''LABEL'' RETURNING REPORTSTYPES.* ),  upsert2 AS ( UPDATE REPORTSTYPES SET LABEL=newinput -> ''LABEL''  WHERE GENERATIONQUERY=newinput -> ''GENERATIONQUERY'' RETURNING REPORTSTYPES.* ) INSERT INTO REPORTSTYPES (SELECT * FROM REPORTSTYPES WHERE NOT EXISTS (  SELECT 1 FROM  upsert1 b1 WHERE (LABEL=b1.LABEL) UNION ALL  SELECT 1 FROM  upsert2 b2 WHERE (GENERATIONQUERY=b2.GENERATIONQUERY) )); SELECT LABEL INTO returnVar FROM REPORTSTYPES WHERE  LABEL=newinput -> ''LABEL'' OR  GENERATIONQUERY=newinput -> ''GENERATIONQUERY'';'; RAISE NOTICE ' ==> %', returnVar; RETURN CAST(returnVar AS TEXT);  EXECUTE query; END; $inner$ LANGUAGE plpgsql; 
(1 ligne)

SELECT gen_upsert('ROOMS', 'ROOMTYPE_ID=CAST(NEW.ROOMTYPE_ID AS INTEGER), FLOOR=CAST(NEW.FLOOR AS SMALLINTEGER), ISCLEANED=CAST(NEW.ISCLEANED AS BOOLEAN)', 'NUMBER=CAST(NEW.NUMBER AS SMALLINTEGER)', 'ID');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     gen_upsert                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION  genupsert_ROOMS(newinput hstore) RETURNS  TEXT AS $inner$ DECLARE returnVar TEXT;  BEGIN  WITH upsert AS ( UPDATE ROOMS SET ROOMTYPE_ID=CAST(newinput -> 'ROOMTYPE_ID' AS INTEGER), FLOOR=CAST(newinput -> 'FLOOR' AS SMALLINTEGER), ISCLEANED=CAST(newinput -> 'ISCLEANED' AS BOOLEAN) WHERE NUMBER=CAST(newinput -> 'NUMBER' AS SMALLINTEGER) RETURNING ROOMS.* )  INSERT INTO ROOMS (SELECT * FROM ROOMS WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE NUMBER=CAST(b.NUMBER AS SMALLINTEGER))) ; SELECT ID INTO returnVar FROM ROOMS WHERE NUMBER=CAST(newinput -> 'NUMBER' AS SMALLINTEGER);  RAISE NOTICE 'WITH upsert AS ( UPDATE ROOMS SET ROOMTYPE_ID=CAST(newinput -> ''ROOMTYPE_ID'' AS INTEGER), FLOOR=CAST(newinput -> ''FLOOR'' AS SMALLINTEGER), ISCLEANED=CAST(newinput -> ''ISCLEANED'' AS BOOLEAN) WHERE NUMBER=CAST(newinput -> ''NUMBER'' AS SMALLINTEGER) RETURNING ROOMS.* )  INSERT INTO ROOMS (SELECT * FROM ROOMS WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE NUMBER=CAST(b.NUMBER AS SMALLINTEGER))) ; SELECT ID INTO returnVar FROM ROOMS WHERE NUMBER=CAST(newinput -> ''NUMBER'' AS SMALLINTEGER);';  RAISE NOTICE ' ==> %', returnVar; RETURN CAST(returnVar AS TEXT);  EXECUTE query; END; $inner$ LANGUAGE plpgsql; 
(1 ligne)

SELECT gen_upsertmult('ROOMSOCCUPATIONS', array['ARRIVINGDATE=CAST(NEW.ARRIVINGDATE AS DATE), DEPARTUREDATE=CAST(NEW.DEPARTUREDATE AS DATE)','BILLING_ID=CAST(NEW.BILLING_ID AS INTEGER), DEPARTUREDATE=CAST(NEW.DEPARTUREDATE AS DATE)','ARRIVINGDATE=CAST(NEW.ARRIVINGDATE AS DATE), BILLING_ID=CAST(NEW.BILLING_ID AS INTEGER)'], array['ROOM_ID=CAST(NEW.ROOM_ID AS INTEGER) AND BILLING_ID=CAST(NEW.BILLING_ID AS INTEGER)','ROOM_ID=CAST(NEW.ROOM_ID AS INTEGER) AND ARRIVINGDATE=CAST(NEW.ARRIVINGDATE AS DATE)','ROOM_ID=CAST(NEW.ROOM_ID AS INTEGER) AND DEPARTUREDATE=CAST(NEW.DEPARTUREDATE AS DATE)'], 'ROOM_ID');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  gen_upsertmult                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION  genupsert_ROOMSOCCUPATIONS(newinput hstore) RETURNS  TEXT AS $inner$ DECLARE returnVar TEXT;  BEGIN   WITH  upsert1 AS ( UPDATE ROOMSOCCUPATIONS SET ARRIVINGDATE=CAST(newinput -> 'ARRIVINGDATE' AS DATE), DEPARTUREDATE=CAST(newinput -> 'DEPARTUREDATE' AS DATE) WHERE ROOM_ID=CAST(newinput -> 'ROOM_ID' AS INTEGER) AND BILLING_ID=CAST(newinput -> 'BILLING_ID' AS INTEGER) RETURNING ROOMSOCCUPATIONS.* ),  upsert2 AS ( UPDATE ROOMSOCCUPATIONS SET BILLING_ID=CAST(newinput -> 'BILLING_ID' AS INTEGER), DEPARTUREDATE=CAST(newinput -> 'DEPARTUREDATE' AS DATE) WHERE ROOM_ID=CAST(newinput -> 'ROOM_ID' AS INTEGER) AND ARRIVINGDATE=CAST(newinput -> 'ARRIVINGDATE' AS DATE) RETURNING ROOMSOCCUPATIONS.* ),  upsert3 AS ( UPDATE ROOMSOCCUPATIONS SET ARRIVINGDATE=CAST(newinput -> 'ARRIVINGDATE' AS DATE), BILLING_ID=CAST(newinput -> 'BILLING_ID' AS INTEGER) WHERE ROOM_ID=CAST(newinput -> 'ROOM_ID' AS INTEGER) AND DEPARTUREDATE=CAST(newinput -> 'DEPARTUREDATE' AS DATE) RETURNING ROOMSOCCUPATIONS.* ) INSERT INTO ROOMSOCCUPATIONS (SELECT * FROM ROOMSOCCUPATIONS WHERE NOT EXISTS (  SELECT 1 FROM  upsert1 b1 WHERE (ROOM_ID=CAST(b1.ROOM_ID AS INTEGER) AND BILLING_ID=CAST(b1.BILLING_ID AS INTEGER)) UNION ALL  SELECT 1 FROM  upsert2 b2 WHERE (ROOM_ID=CAST(b2.ROOM_ID AS INTEGER) AND ARRIVINGDATE=CAST(b2.ARRIVINGDATE AS DATE)) UNION ALL  SELECT 1 FROM  upsert3 b3 WHERE (ROOM_ID=CAST(b3.ROOM_ID AS INTEGER) AND DEPARTUREDATE=CAST(b3.DEPARTUREDATE AS DATE)) )); SELECT ROOM_ID INTO returnVar FROM ROOMSOCCUPATIONS WHERE  ROOM_ID=CAST(newinput -> 'ROOM_ID' AS INTEGER) AND BILLING_ID=CAST(newinput -> 'BILLING_ID' AS INTEGER) OR  ROOM_ID=CAST(newinput -> 'ROOM_ID' AS INTEGER) AND ARRIVINGDATE=CAST(newinput -> 'ARRIVINGDATE' AS DATE) OR  ROOM_ID=CAST(newinput -> 'ROOM_ID' AS INTEGER) AND DEPARTUREDATE=CAST(newinput -> 'DEPARTUREDATE' AS DATE); RAISE NOTICE ' WITH  upsert1 AS ( UPDATE ROOMSOCCUPATIONS SET ARRIVINGDATE=CAST(newinput -> ''ARRIVINGDATE'' AS DATE), DEPARTUREDATE=CAST(newinput -> ''DEPARTUREDATE'' AS DATE) WHERE ROOM_ID=CAST(newinput -> ''ROOM_ID'' AS INTEGER) AND BILLING_ID=CAST(newinput -> ''BILLING_ID'' AS INTEGER) RETURNING ROOMSOCCUPATIONS.* ),  upsert2 AS ( UPDATE ROOMSOCCUPATIONS SET BILLING_ID=CAST(newinput -> ''BILLING_ID'' AS INTEGER), DEPARTUREDATE=CAST(newinput -> ''DEPARTUREDATE'' AS DATE) WHERE ROOM_ID=CAST(newinput -> ''ROOM_ID'' AS INTEGER) AND ARRIVINGDATE=CAST(newinput -> ''ARRIVINGDATE'' AS DATE) RETURNING ROOMSOCCUPATIONS.* ),  upsert3 AS ( UPDATE ROOMSOCCUPATIONS SET ARRIVINGDATE=CAST(newinput -> ''ARRIVINGDATE'' AS DATE), BILLING_ID=CAST(newinput -> ''BILLING_ID'' AS INTEGER) WHERE ROOM_ID=CAST(newinput -> ''ROOM_ID'' AS INTEGER) AND DEPARTUREDATE=CAST(newinput -> ''DEPARTUREDATE'' AS DATE) RETURNING ROOMSOCCUPATIONS.* ) INSERT INTO ROOMSOCCUPATIONS (SELECT * FROM ROOMSOCCUPATIONS WHERE NOT EXISTS (  SELECT 1 FROM  upsert1 b1 WHERE (ROOM_ID=CAST(b1.ROOM_ID AS INTEGER) AND BILLING_ID=CAST(b1.BILLING_ID AS INTEGER)) UNION ALL  SELECT 1 FROM  upsert2 b2 WHERE (ROOM_ID=CAST(b2.ROOM_ID AS INTEGER) AND ARRIVINGDATE=CAST(b2.ARRIVINGDATE AS DATE)) UNION ALL  SELECT 1 FROM  upsert3 b3 WHERE (ROOM_ID=CAST(b3.ROOM_ID AS INTEGER) AND DEPARTUREDATE=CAST(b3.DEPARTUREDATE AS DATE)) )); SELECT ROOM_ID INTO returnVar FROM ROOMSOCCUPATIONS WHERE  ROOM_ID=CAST(newinput -> ''ROOM_ID'' AS INTEGER) AND BILLING_ID=CAST(newinput -> ''BILLING_ID'' AS INTEGER) OR  ROOM_ID=CAST(newinput -> ''ROOM_ID'' AS INTEGER) AND ARRIVINGDATE=CAST(newinput -> ''ARRIVINGDATE'' AS DATE) OR  ROOM_ID=CAST(newinput -> ''ROOM_ID'' AS INTEGER) AND DEPARTUREDATE=CAST(newinput -> ''DEPARTUREDATE'' AS DATE);'; RAISE NOTICE ' ==> %', returnVar; RETURN CAST(returnVar AS TEXT);  EXECUTE query; END; $inner$ LANGUAGE plpgsql; 
(1 ligne)

SELECT gen_upsert('ROOMSTYPES', 'DESCRIPTION=NEW.DESCRIPTION, PRICEMIN=CAST(NEW.PRICEMIN AS DECIMAL), PRICEMAX=CAST(NEW.PRICEMAX AS DECIMAL)', 'LABEL=NEW.LABEL', 'ID');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         gen_upsert                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION  genupsert_ROOMSTYPES(newinput hstore) RETURNS  TEXT AS $inner$ DECLARE returnVar TEXT;  BEGIN  WITH upsert AS ( UPDATE ROOMSTYPES SET DESCRIPTION=newinput -> 'DESCRIPTION', PRICEMIN=CAST(newinput -> 'PRICEMIN' AS DECIMAL), PRICEMAX=CAST(newinput -> 'PRICEMAX' AS DECIMAL) WHERE LABEL=newinput -> 'LABEL'  RETURNING ROOMSTYPES.* )  INSERT INTO ROOMSTYPES (SELECT * FROM ROOMSTYPES WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE LABEL=b.LABEL)) ; SELECT ID INTO returnVar FROM ROOMSTYPES WHERE LABEL=newinput -> 'LABEL' ;  RAISE NOTICE 'WITH upsert AS ( UPDATE ROOMSTYPES SET DESCRIPTION=newinput -> ''DESCRIPTION'', PRICEMIN=CAST(newinput -> ''PRICEMIN'' AS DECIMAL), PRICEMAX=CAST(newinput -> ''PRICEMAX'' AS DECIMAL) WHERE LABEL=newinput -> ''LABEL''  RETURNING ROOMSTYPES.* )  INSERT INTO ROOMSTYPES (SELECT * FROM ROOMSTYPES WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE LABEL=b.LABEL)) ; SELECT ID INTO returnVar FROM ROOMSTYPES WHERE LABEL=newinput -> ''LABEL'' ;';  RAISE NOTICE ' ==> %', returnVar; RETURN CAST(returnVar AS TEXT);  EXECUTE query; END; $inner$ LANGUAGE plpgsql; 
(1 ligne)

SELECT gen_upsert('SERVICESDETAILS', 'FIELDVALUE=NEW.FIELDVALUE', 'SERVICEFIELD_ID=CAST(NEW.SERVICEFIELD_ID AS INTEGER) AND SERVICE_ID=CAST(NEW.SERVICE_ID AS INTEGER)', 'ID');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           gen_upsert                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION  genupsert_SERVICESDETAILS(newinput hstore) RETURNS  TEXT AS $inner$ DECLARE returnVar TEXT;  BEGIN  WITH upsert AS ( UPDATE SERVICESDETAILS SET FIELDVALUE=newinput -> 'FIELDVALUE'  WHERE SERVICEFIELD_ID=CAST(newinput -> 'SERVICEFIELD_ID' AS INTEGER) AND SERVICE_ID=CAST(newinput -> 'SERVICE_ID' AS INTEGER) RETURNING SERVICESDETAILS.* )  INSERT INTO SERVICESDETAILS (SELECT * FROM SERVICESDETAILS WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE SERVICEFIELD_ID=CAST(b.SERVICEFIELD_ID AS INTEGER) AND SERVICE_ID=CAST(b.SERVICE_ID AS INTEGER))) ; SELECT ID INTO returnVar FROM SERVICESDETAILS WHERE SERVICEFIELD_ID=CAST(newinput -> 'SERVICEFIELD_ID' AS INTEGER) AND SERVICE_ID=CAST(newinput -> 'SERVICE_ID' AS INTEGER);  RAISE NOTICE 'WITH upsert AS ( UPDATE SERVICESDETAILS SET FIELDVALUE=newinput -> ''FIELDVALUE''  WHERE SERVICEFIELD_ID=CAST(newinput -> ''SERVICEFIELD_ID'' AS INTEGER) AND SERVICE_ID=CAST(newinput -> ''SERVICE_ID'' AS INTEGER) RETURNING SERVICESDETAILS.* )  INSERT INTO SERVICESDETAILS (SELECT * FROM SERVICESDETAILS WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE SERVICEFIELD_ID=CAST(b.SERVICEFIELD_ID AS INTEGER) AND SERVICE_ID=CAST(b.SERVICE_ID AS INTEGER))) ; SELECT ID INTO returnVar FROM SERVICESDETAILS WHERE SERVICEFIELD_ID=CAST(newinput -> ''SERVICEFIELD_ID'' AS INTEGER) AND SERVICE_ID=CAST(newinput -> ''SERVICE_ID'' AS INTEGER);';  RAISE NOTICE ' ==> %', returnVar; RETURN CAST(returnVar AS TEXT);  EXECUTE query; END; $inner$ LANGUAGE plpgsql; 
(1 ligne)

SELECT gen_upsert('SERVICESFIELDS', 'SQLTYPE=NEW.SQLTYPE', 'LABEL=NEW.LABEL', 'ID');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  gen_upsert                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION  genupsert_SERVICESFIELDS(newinput hstore) RETURNS  TEXT AS $inner$ DECLARE returnVar TEXT;  BEGIN  WITH upsert AS ( UPDATE SERVICESFIELDS SET SQLTYPE=newinput -> 'SQLTYPE'  WHERE LABEL=newinput -> 'LABEL'  RETURNING SERVICESFIELDS.* )  INSERT INTO SERVICESFIELDS (SELECT * FROM SERVICESFIELDS WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE LABEL=b.LABEL)) ; SELECT ID INTO returnVar FROM SERVICESFIELDS WHERE LABEL=newinput -> 'LABEL' ;  RAISE NOTICE 'WITH upsert AS ( UPDATE SERVICESFIELDS SET SQLTYPE=newinput -> ''SQLTYPE''  WHERE LABEL=newinput -> ''LABEL''  RETURNING SERVICESFIELDS.* )  INSERT INTO SERVICESFIELDS (SELECT * FROM SERVICESFIELDS WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE LABEL=b.LABEL)) ; SELECT ID INTO returnVar FROM SERVICESFIELDS WHERE LABEL=newinput -> ''LABEL'' ;';  RAISE NOTICE ' ==> %', returnVar; RETURN CAST(returnVar AS TEXT);  EXECUTE query; END; $inner$ LANGUAGE plpgsql; 
(1 ligne)

SELECT gen_upsert('SERVICES', 'SERVICETYPE_ID=CAST(NEW.SERVICETYPE_ID AS INTEGER), ISAVAILABLE=CAST(NEW.ISAVAILABLE AS BOOLEAN)', 'NAME=NEW.NAME', 'ID');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  gen_upsert                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION  genupsert_SERVICES(newinput hstore) RETURNS  TEXT AS $inner$ DECLARE returnVar TEXT;  BEGIN  WITH upsert AS ( UPDATE SERVICES SET SERVICETYPE_ID=CAST(newinput -> 'SERVICETYPE_ID' AS INTEGER), ISAVAILABLE=CAST(newinput -> 'ISAVAILABLE' AS BOOLEAN) WHERE NAME=newinput -> 'NAME'  RETURNING SERVICES.* )  INSERT INTO SERVICES (SELECT * FROM SERVICES WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE NAME=b.NAME)) ; SELECT ID INTO returnVar FROM SERVICES WHERE NAME=newinput -> 'NAME' ;  RAISE NOTICE 'WITH upsert AS ( UPDATE SERVICES SET SERVICETYPE_ID=CAST(newinput -> ''SERVICETYPE_ID'' AS INTEGER), ISAVAILABLE=CAST(newinput -> ''ISAVAILABLE'' AS BOOLEAN) WHERE NAME=newinput -> ''NAME''  RETURNING SERVICES.* )  INSERT INTO SERVICES (SELECT * FROM SERVICES WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE NAME=b.NAME)) ; SELECT ID INTO returnVar FROM SERVICES WHERE NAME=newinput -> ''NAME'' ;';  RAISE NOTICE ' ==> %', returnVar; RETURN CAST(returnVar AS TEXT);  EXECUTE query; END; $inner$ LANGUAGE plpgsql; 
(1 ligne)

SELECT gen_upsert('SERVICESTYPES', 'SERVICEFAMILY_ID=CAST(NEW.SERVICEFAMILY_ID AS INTEGER), VAT_ID=CAST(NEW.VAT_ID AS INTEGER), ROOMNEEDED=CAST(NEW.ROOMNEEDED AS BOOLEAN)', 'LABEL=NEW.LABEL', 'ID');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    gen_upsert                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION  genupsert_SERVICESTYPES(newinput hstore) RETURNS  TEXT AS $inner$ DECLARE returnVar TEXT;  BEGIN  WITH upsert AS ( UPDATE SERVICESTYPES SET SERVICEFAMILY_ID=CAST(newinput -> 'SERVICEFAMILY_ID' AS INTEGER), VAT_ID=CAST(newinput -> 'VAT_ID' AS INTEGER), ROOMNEEDED=CAST(newinput -> 'ROOMNEEDED' AS BOOLEAN) WHERE LABEL=newinput -> 'LABEL'  RETURNING SERVICESTYPES.* )  INSERT INTO SERVICESTYPES (SELECT * FROM SERVICESTYPES WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE LABEL=b.LABEL)) ; SELECT ID INTO returnVar FROM SERVICESTYPES WHERE LABEL=newinput -> 'LABEL' ;  RAISE NOTICE 'WITH upsert AS ( UPDATE SERVICESTYPES SET SERVICEFAMILY_ID=CAST(newinput -> ''SERVICEFAMILY_ID'' AS INTEGER), VAT_ID=CAST(newinput -> ''VAT_ID'' AS INTEGER), ROOMNEEDED=CAST(newinput -> ''ROOMNEEDED'' AS BOOLEAN) WHERE LABEL=newinput -> ''LABEL''  RETURNING SERVICESTYPES.* )  INSERT INTO SERVICESTYPES (SELECT * FROM SERVICESTYPES WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE LABEL=b.LABEL)) ; SELECT ID INTO returnVar FROM SERVICESTYPES WHERE LABEL=newinput -> ''LABEL'' ;';  RAISE NOTICE ' ==> %', returnVar; RETURN CAST(returnVar AS TEXT);  EXECUTE query; END; $inner$ LANGUAGE plpgsql; 
(1 ligne)

SELECT gen_upsert('USERS', 'ENCRYPTEDPASS=NEW.ENCRYPTEDPASS, ISRECEPTIONIST=CAST(NEW.ISRECEPTIONIST AS BOOLEAN), ISMANAGERX=CAST(NEW.ISMANAGERX AS BOOLEAN), ISMANAGERZ=CAST(NEW.ISMANAGERZ AS BOOLEAN), ISADMINISTRATOR=CAST(NEW.ISADMINISTRATOR AS BOOLEAN)', 'LOGIN=NEW.LOGIN', 'ID');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         gen_upsert                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION  genupsert_USERS(newinput hstore) RETURNS  TEXT AS $inner$ DECLARE returnVar TEXT;  BEGIN  WITH upsert AS ( UPDATE USERS SET ENCRYPTEDPASS=newinput -> 'ENCRYPTEDPASS', ISRECEPTIONIST=CAST(newinput -> 'ISRECEPTIONIST' AS BOOLEAN), ISMANAGERX=CAST(newinput -> 'ISMANAGERX' AS BOOLEAN), ISMANAGERZ=CAST(newinput -> 'ISMANAGERZ' AS BOOLEAN), ISADMINISTRATOR=CAST(newinput -> 'ISADMINISTRATOR' AS BOOLEAN) WHERE LOGIN=newinput -> 'LOGIN'  RETURNING USERS.* )  INSERT INTO USERS (SELECT * FROM USERS WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE LOGIN=b.LOGIN)) ; SELECT ID INTO returnVar FROM USERS WHERE LOGIN=newinput -> 'LOGIN' ;  RAISE NOTICE 'WITH upsert AS ( UPDATE USERS SET ENCRYPTEDPASS=newinput -> ''ENCRYPTEDPASS'', ISRECEPTIONIST=CAST(newinput -> ''ISRECEPTIONIST'' AS BOOLEAN), ISMANAGERX=CAST(newinput -> ''ISMANAGERX'' AS BOOLEAN), ISMANAGERZ=CAST(newinput -> ''ISMANAGERZ'' AS BOOLEAN), ISADMINISTRATOR=CAST(newinput -> ''ISADMINISTRATOR'' AS BOOLEAN) WHERE LOGIN=newinput -> ''LOGIN''  RETURNING USERS.* )  INSERT INTO USERS (SELECT * FROM USERS WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE LOGIN=b.LOGIN)) ; SELECT ID INTO returnVar FROM USERS WHERE LOGIN=newinput -> ''LOGIN'' ;';  RAISE NOTICE ' ==> %', returnVar; RETURN CAST(returnVar AS TEXT);  EXECUTE query; END; $inner$ LANGUAGE plpgsql; 
(1 ligne)

SELECT gen_upsert('TRAINEES', 'ENCRYPTEDPASS=NEW.ENCRYPTEDPASS, ISACTIVATED=CAST(NEW.ISACTIVATED AS BOOLEAN)', 'LOGIN=NEW.LOGIN', 'ID');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     gen_upsert                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION  genupsert_TRAINEES(newinput hstore) RETURNS  TEXT AS $inner$ DECLARE returnVar TEXT;  BEGIN  WITH upsert AS ( UPDATE TRAINEES SET ENCRYPTEDPASS=newinput -> 'ENCRYPTEDPASS', ISACTIVATED=CAST(newinput -> 'ISACTIVATED' AS BOOLEAN) WHERE LOGIN=newinput -> 'LOGIN'  RETURNING TRAINEES.* )  INSERT INTO TRAINEES (SELECT * FROM TRAINEES WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE LOGIN=b.LOGIN)) ; SELECT ID INTO returnVar FROM TRAINEES WHERE LOGIN=newinput -> 'LOGIN' ;  RAISE NOTICE 'WITH upsert AS ( UPDATE TRAINEES SET ENCRYPTEDPASS=newinput -> ''ENCRYPTEDPASS'', ISACTIVATED=CAST(newinput -> ''ISACTIVATED'' AS BOOLEAN) WHERE LOGIN=newinput -> ''LOGIN''  RETURNING TRAINEES.* )  INSERT INTO TRAINEES (SELECT * FROM TRAINEES WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE LOGIN=b.LOGIN)) ; SELECT ID INTO returnVar FROM TRAINEES WHERE LOGIN=newinput -> ''LOGIN'' ;';  RAISE NOTICE ' ==> %', returnVar; RETURN CAST(returnVar AS TEXT);  EXECUTE query; END; $inner$ LANGUAGE plpgsql; 
(1 ligne)

SELECT gen_upsert('ADDRESSES_ARCHIVE', 'client_id=CAST(NEW.client_ID AS INTEGER), zipcode=NEW.zipcode, phone=NEW.phone,complementaryline=NEW.complementaryline', 'contact=NEW.contact AND street=NEW.street AND number=NEW.number AND city=NEW.city AND country=NEW.country', 'ID');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    gen_upsert                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION  genupsert_ADDRESSES_ARCHIVE(newinput hstore) RETURNS  TEXT AS $inner$ DECLARE returnVar TEXT;  BEGIN  WITH upsert AS ( UPDATE ADDRESSES_ARCHIVE SET client_id=CAST(newinput -> 'client_ID' AS INTEGER), zipcode=newinput -> 'zipcode', phone=newinput -> 'phone',complementaryline=newinput -> 'complementaryline'  WHERE contact=newinput -> 'contact' AND street=newinput -> 'street' AND number=newinput -> 'number' AND city=newinput -> 'city' AND country=newinput -> 'country'  RETURNING ADDRESSES_ARCHIVE.* )  INSERT INTO ADDRESSES_ARCHIVE (SELECT * FROM ADDRESSES_ARCHIVE WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE contact=b.contact AND street=b.street AND number=b.number AND city=b.city AND country=b.country)) ; SELECT ID INTO returnVar FROM ADDRESSES_ARCHIVE WHERE contact=newinput -> 'contact' AND street=newinput -> 'street' AND number=newinput -> 'number' AND city=newinput -> 'city' AND country=newinput -> 'country' ;  RAISE NOTICE 'WITH upsert AS ( UPDATE ADDRESSES_ARCHIVE SET client_id=CAST(newinput -> ''client_ID'' AS INTEGER), zipcode=newinput -> ''zipcode'', phone=newinput -> ''phone'',complementaryline=newinput -> ''complementaryline''  WHERE contact=newinput -> ''contact'' AND street=newinput -> ''street'' AND number=newinput -> ''number'' AND city=newinput -> ''city'' AND country=newinput -> ''country''  RETURNING ADDRESSES_ARCHIVE.* )  INSERT INTO ADDRESSES_ARCHIVE (SELECT * FROM ADDRESSES_ARCHIVE WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE contact=b.contact AND street=b.street AND number=b.number AND city=b.city AND country=b.country)) ; SELECT ID INTO returnVar FROM ADDRESSES_ARCHIVE WHERE contact=newinput -> ''contact'' AND street=newinput -> ''street'' AND number=newinput -> ''number'' AND city=newinput -> ''city'' AND country=newinput -> ''country'' ;';  RAISE NOTICE ' ==> %', returnVar; RETURN CAST(returnVar AS TEXT);  EXECUTE query; END; $inner$ LANGUAGE plpgsql; 
(1 ligne)

SELECT gen_upsert('GROUPS_ARCHIVE', 'CONTACT_ID=CAST(NEW.CONTACT_ID AS INTEGER)', 'NAME=NEW.NAME', 'ID');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  gen_upsert                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION  genupsert_GROUPS_ARCHIVE(newinput hstore) RETURNS  TEXT AS $inner$ DECLARE returnVar TEXT;  BEGIN  WITH upsert AS ( UPDATE GROUPS_ARCHIVE SET CONTACT_ID=CAST(newinput -> 'CONTACT_ID' AS INTEGER) WHERE NAME=newinput -> 'NAME'  RETURNING GROUPS_ARCHIVE.* )  INSERT INTO GROUPS_ARCHIVE (SELECT * FROM GROUPS_ARCHIVE WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE NAME=b.NAME)) ; SELECT ID INTO returnVar FROM GROUPS_ARCHIVE WHERE NAME=newinput -> 'NAME' ;  RAISE NOTICE 'WITH upsert AS ( UPDATE GROUPS_ARCHIVE SET CONTACT_ID=CAST(newinput -> ''CONTACT_ID'' AS INTEGER) WHERE NAME=newinput -> ''NAME''  RETURNING GROUPS_ARCHIVE.* )  INSERT INTO GROUPS_ARCHIVE (SELECT * FROM GROUPS_ARCHIVE WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE NAME=b.NAME)) ; SELECT ID INTO returnVar FROM GROUPS_ARCHIVE WHERE NAME=newinput -> ''NAME'' ;';  RAISE NOTICE ' ==> %', returnVar; RETURN CAST(returnVar AS TEXT);  EXECUTE query; END; $inner$ LANGUAGE plpgsql; 
(1 ligne)

SELECT gen_upsert('BALANCELOG_ARCHIVE', 'balance=CAST(NEW.balance AS DECIMAL)', 'yearlog=CAST(NEW.yearlog AS SMALLINTEGER) AND monthlog=CAST(NEW.monthlog AS SMALLINTEGER) AND daylog=CAST(NEW.daylog AS SMALLINTEGER) AND hourlog=CAST(NEW.hourlog AS SMALLINTEGER)', 'BALANCE');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   gen_upsert                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION  genupsert_BALANCELOG_ARCHIVE(newinput hstore) RETURNS  TEXT AS $inner$ DECLARE returnVar TEXT;  BEGIN  WITH upsert AS ( UPDATE BALANCELOG_ARCHIVE SET balance=CAST(newinput -> 'balance' AS DECIMAL) WHERE yearlog=CAST(newinput -> 'yearlog' AS SMALLINTEGER) AND monthlog=CAST(newinput -> 'monthlog' AS SMALLINTEGER) AND daylog=CAST(newinput -> 'daylog' AS SMALLINTEGER) AND hourlog=CAST(newinput -> 'hourlog' AS SMALLINTEGER) RETURNING BALANCELOG_ARCHIVE.* )  INSERT INTO BALANCELOG_ARCHIVE (SELECT * FROM BALANCELOG_ARCHIVE WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE yearlog=CAST(b.yearlog AS SMALLINTEGER) AND monthlog=CAST(b.monthlog AS SMALLINTEGER) AND daylog=CAST(b.daylog AS SMALLINTEGER) AND hourlog=CAST(b.hourlog AS SMALLINTEGER))) ; SELECT BALANCE INTO returnVar FROM BALANCELOG_ARCHIVE WHERE yearlog=CAST(newinput -> 'yearlog' AS SMALLINTEGER) AND monthlog=CAST(newinput -> 'monthlog' AS SMALLINTEGER) AND daylog=CAST(newinput -> 'daylog' AS SMALLINTEGER) AND hourlog=CAST(newinput -> 'hourlog' AS SMALLINTEGER);  RAISE NOTICE 'WITH upsert AS ( UPDATE BALANCELOG_ARCHIVE SET balance=CAST(newinput -> ''balance'' AS DECIMAL) WHERE yearlog=CAST(newinput -> ''yearlog'' AS SMALLINTEGER) AND monthlog=CAST(newinput -> ''monthlog'' AS SMALLINTEGER) AND daylog=CAST(newinput -> ''daylog'' AS SMALLINTEGER) AND hourlog=CAST(newinput -> ''hourlog'' AS SMALLINTEGER) RETURNING BALANCELOG_ARCHIVE.* )  INSERT INTO BALANCELOG_ARCHIVE (SELECT * FROM BALANCELOG_ARCHIVE WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE yearlog=CAST(b.yearlog AS SMALLINTEGER) AND monthlog=CAST(b.monthlog AS SMALLINTEGER) AND daylog=CAST(b.daylog AS SMALLINTEGER) AND hourlog=CAST(b.hourlog AS SMALLINTEGER))) ; SELECT BALANCE INTO returnVar FROM BALANCELOG_ARCHIVE WHERE yearlog=CAST(newinput -> ''yearlog'' AS SMALLINTEGER) AND monthlog=CAST(newinput -> ''monthlog'' AS SMALLINTEGER) AND daylog=CAST(newinput -> ''daylog'' AS SMALLINTEGER) AND hourlog=CAST(newinput -> ''hourlog'' AS SMALLINTEGER);';  RAISE NOTICE ' ==> %', returnVar; RETURN CAST(returnVar AS TEXT);  EXECUTE query; END; $inner$ LANGUAGE plpgsql; 
(1 ligne)

SELECT gen_upsert('NATIONALITIES_ARCHIVE', 'COUNTRY=NEW.COUNTRY, LONGISOCODE=NEW.LONGISOCODE, ISOCODE=NEW.ISOCODE', 'CODE=CAST(NEW.CODE AS SMALLINTEGER)', 'ID');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          gen_upsert                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION  genupsert_NATIONALITIES_ARCHIVE(newinput hstore) RETURNS  TEXT AS $inner$ DECLARE returnVar TEXT;  BEGIN  WITH upsert AS ( UPDATE NATIONALITIES_ARCHIVE SET COUNTRY=newinput -> 'COUNTRY', LONGISOCODE=newinput -> 'LONGISOCODE', ISOCODE=newinput -> 'ISOCODE'  WHERE CODE=CAST(newinput -> 'CODE' AS SMALLINTEGER) RETURNING NATIONALITIES_ARCHIVE.* )  INSERT INTO NATIONALITIES_ARCHIVE (SELECT * FROM NATIONALITIES_ARCHIVE WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE CODE=CAST(b.CODE AS SMALLINTEGER))) ; SELECT ID INTO returnVar FROM NATIONALITIES_ARCHIVE WHERE CODE=CAST(newinput -> 'CODE' AS SMALLINTEGER);  RAISE NOTICE 'WITH upsert AS ( UPDATE NATIONALITIES_ARCHIVE SET COUNTRY=newinput -> ''COUNTRY'', LONGISOCODE=newinput -> ''LONGISOCODE'', ISOCODE=newinput -> ''ISOCODE''  WHERE CODE=CAST(newinput -> ''CODE'' AS SMALLINTEGER) RETURNING NATIONALITIES_ARCHIVE.* )  INSERT INTO NATIONALITIES_ARCHIVE (SELECT * FROM NATIONALITIES_ARCHIVE WHERE NOT EXISTS (SELECT 1 FROM upsert b WHERE CODE=CAST(b.CODE AS SMALLINTEGER))) ; SELECT ID INTO returnVar FROM NATIONALITIES_ARCHIVE WHERE CODE=CAST(newinput -> ''CODE'' AS SMALLINTEGER);';  RAISE NOTICE ' ==> %', returnVar; RETURN CAST(returnVar AS TEXT);  EXECUTE query; END; $inner$ LANGUAGE plpgsql; 
(1 ligne)

SELECT gen_upsertmult('CLIENTS_ARCHIVE', array['NAME=NEW.NAME, PHONE=NEW.PHONE, IDCARDSCAN=NEW.IDCARDSCAN, NATIONALITY_ID=CAST(NEW.NATIONALITY_ID AS INTEGER), HOMEADDRESS_ID=CAST(NEW.HOMEADDRESS_ID AS INTEGER), ISCURRENT=CAST(NEW.ISCURRENT AS BOOLEAN)','EMAIL=NEW.EMAIL, PHONE=NEW.PHONE, NATIONALITY_ID=CAST(NEW.NATIONALITY_ID AS INTEGER), HOMEADDRESS_ID=CAST(NEW.HOMEADDRESS_ID AS INTEGER),ISCURRENT=CAST(NEW.ISCURRENT AS BOOLEAN)', 'EMAIL=NEW.EMAIL, PHONE=NEW.PHONE, IDCARDSCAN=NEW.IDCARDSCAN, NATIONALITY_ID=CAST(NEW.NATIONALITY_ID AS INTEGER), ISCURRENT=CAST(NEW.ISCURRENT AS BOOLEAN)'], array['EMAIL=NEW.EMAIL','NAME=NEW.NAME AND IDCARDSCAN=NEW.IDCARDSCAN AND IDCARDSCAN IS NOT NULL','NAME=NEW.NAME AND HOMEADDRESS_ID=CAST(NEW.HOMEADDRESS_ID AS INTEGER) AND HOMEADDRESS_ID IS NOT NULL'], 'ID');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        gen_upsertmult                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION  genupsert_CLIENTS_ARCHIVE(newinput hstore) RETURNS  TEXT AS $inner$ DECLARE returnVar TEXT;  BEGIN   WITH  upsert1 AS ( UPDATE CLIENTS_ARCHIVE SET NAME=newinput -> 'NAME', PHONE=newinput -> 'PHONE', IDCARDSCAN=newinput -> 'IDCARDSCAN', NATIONALITY_ID=CAST(newinput -> 'NATIONALITY_ID' AS INTEGER), HOMEADDRESS_ID=CAST(newinput -> 'HOMEADDRESS_ID' AS INTEGER), ISCURRENT=CAST(newinput -> 'ISCURRENT' AS BOOLEAN) WHERE EMAIL=newinput -> 'EMAIL' RETURNING CLIENTS_ARCHIVE.* ),  upsert2 AS ( UPDATE CLIENTS_ARCHIVE SET EMAIL=newinput -> 'EMAIL', PHONE=newinput -> 'PHONE', NATIONALITY_ID=CAST(newinput -> 'NATIONALITY_ID' AS INTEGER), HOMEADDRESS_ID=CAST(newinput -> 'HOMEADDRESS_ID' AS INTEGER),ISCURRENT=CAST(newinput -> 'ISCURRENT' AS BOOLEAN) WHERE NAME=newinput -> 'NAME' AND IDCARDSCAN=newinput -> 'IDCARDSCAN' AND IDCARDSCAN IS NOT NULL RETURNING CLIENTS_ARCHIVE.* ),  upsert3 AS ( UPDATE CLIENTS_ARCHIVE SET EMAIL=newinput -> 'EMAIL', PHONE=newinput -> 'PHONE', IDCARDSCAN=newinput -> 'IDCARDSCAN', NATIONALITY_ID=CAST(newinput -> 'NATIONALITY_ID' AS INTEGER), ISCURRENT=CAST(newinput -> 'ISCURRENT' AS BOOLEAN) WHERE NAME=newinput -> 'NAME' AND HOMEADDRESS_ID=CAST(newinput -> 'HOMEADDRESS_ID' AS INTEGER) AND HOMEADDRESS_ID IS NOT NULL RETURNING CLIENTS_ARCHIVE.* ) INSERT INTO CLIENTS_ARCHIVE (SELECT * FROM CLIENTS_ARCHIVE WHERE NOT EXISTS (  SELECT 1 FROM  upsert1 b1 WHERE (EMAIL=b1.EMAIL) UNION ALL  SELECT 1 FROM  upsert2 b2 WHERE (NAME=b2.NAME AND IDCARDSCAN=b2.IDCARDSCAN AND IDCARDSCAN IS NOT NULL) UNION ALL  SELECT 1 FROM  upsert3 b3 WHERE (NAME=b3.NAME AND HOMEADDRESS_ID=CAST(b3.HOMEADDRESS_ID AS INTEGER) AND HOMEADDRESS_ID IS NOT NULL) )); SELECT ID INTO returnVar FROM CLIENTS_ARCHIVE WHERE  EMAIL=newinput -> 'EMAIL' OR  NAME=newinput -> 'NAME' AND IDCARDSCAN=newinput -> 'IDCARDSCAN' AND IDCARDSCAN IS NOT NULL OR  NAME=newinput -> 'NAME' AND HOMEADDRESS_ID=CAST(newinput -> 'HOMEADDRESS_ID' AS INTEGER) AND HOMEADDRESS_ID IS NOT NULL; RAISE NOTICE ' WITH  upsert1 AS ( UPDATE CLIENTS_ARCHIVE SET NAME=newinput -> ''NAME'', PHONE=newinput -> ''PHONE'', IDCARDSCAN=newinput -> ''IDCARDSCAN'', NATIONALITY_ID=CAST(newinput -> ''NATIONALITY_ID'' AS INTEGER), HOMEADDRESS_ID=CAST(newinput -> ''HOMEADDRESS_ID'' AS INTEGER), ISCURRENT=CAST(newinput -> ''ISCURRENT'' AS BOOLEAN) WHERE EMAIL=newinput -> ''EMAIL'' RETURNING CLIENTS_ARCHIVE.* ),  upsert2 AS ( UPDATE CLIENTS_ARCHIVE SET EMAIL=newinput -> ''EMAIL'', PHONE=newinput -> ''PHONE'', NATIONALITY_ID=CAST(newinput -> ''NATIONALITY_ID'' AS INTEGER), HOMEADDRESS_ID=CAST(newinput -> ''HOMEADDRESS_ID'' AS INTEGER),ISCURRENT=CAST(newinput -> ''ISCURRENT'' AS BOOLEAN) WHERE NAME=newinput -> ''NAME'' AND IDCARDSCAN=newinput -> ''IDCARDSCAN'' AND IDCARDSCAN IS NOT NULL RETURNING CLIENTS_ARCHIVE.* ),  upsert3 AS ( UPDATE CLIENTS_ARCHIVE SET EMAIL=newinput -> ''EMAIL'', PHONE=newinput -> ''PHONE'', IDCARDSCAN=newinput -> ''IDCARDSCAN'', NATIONALITY_ID=CAST(newinput -> ''NATIONALITY_ID'' AS INTEGER), ISCURRENT=CAST(newinput -> ''ISCURRENT'' AS BOOLEAN) WHERE NAME=newinput -> ''NAME'' AND HOMEADDRESS_ID=CAST(newinput -> ''HOMEADDRESS_ID'' AS INTEGER) AND HOMEADDRESS_ID IS NOT NULL RETURNING CLIENTS_ARCHIVE.* ) INSERT INTO CLIENTS_ARCHIVE (SELECT * FROM CLIENTS_ARCHIVE WHERE NOT EXISTS (  SELECT 1 FROM  upsert1 b1 WHERE (EMAIL=b1.EMAIL) UNION ALL  SELECT 1 FROM  upsert2 b2 WHERE (NAME=b2.NAME AND IDCARDSCAN=b2.IDCARDSCAN AND IDCARDSCAN IS NOT NULL) UNION ALL  SELECT 1 FROM  upsert3 b3 WHERE (NAME=b3.NAME AND HOMEADDRESS_ID=CAST(b3.HOMEADDRESS_ID AS INTEGER) AND HOMEADDRESS_ID IS NOT NULL) )); SELECT ID INTO returnVar FROM CLIENTS_ARCHIVE WHERE  EMAIL=newinput -> ''EMAIL'' OR  NAME=newinput -> ''NAME'' AND IDCARDSCAN=newinput -> ''IDCARDSCAN'' AND IDCARDSCAN IS NOT NULL OR  NAME=newinput -> ''NAME'' AND HOMEADDRESS_ID=CAST(newinput -> ''HOMEADDRESS_ID'' AS INTEGER) AND HOMEADDRESS_ID IS NOT NULL;'; RAISE NOTICE ' ==> %', returnVar; RETURN CAST(returnVar AS TEXT);  EXECUTE query; END; $inner$ LANGUAGE plpgsql; 
(1 ligne)

INSERT INTO ROOMSTYPES
  (LABEL, DESCRIPTION, PRICEMIN, PRICEMAX)
VALUES
  ('1L+D', '1 lit en 80x200 + 1 douche', 100, 120),
  ('1GL+D', '1 lit en 160x200 + 1 douche', 120, 150),
  ('1pGL+D', '1 lit en 140x190 ou en 140x200 + 1 douche', 135, 145),
  ('2L+D', '2 lits en 80x200 + 1 douche', 150, 165),
  ('2L+B', '2 lits en 80x200 + 1 baignoire', 150, 165),
  ('2Lc+D', '2 lits en 90x200 + 1 douche', 160, 180),
  ('2Lc+B', '2 lits en 90x200 + 1 baignoire', 160, 180),
  ('Junior Suite', '2 lits en 90x200 ou 1 lit 140x200 + 1 baignoire', 170, 195),
  ('3L+B', '3 lits en 80x200 + 1 baignoire', 175, 200),
  ('2L+1pGL+B', '2 lits en 80x200 + 1 lit 140x200 + 1 baignoire', 185, 215),
  ('3L+1pGL+B', '3 lits en 80x200 + 1 lit 140x200 + 1 baignoire', 195, 255),
  ('appartement', '', 300, 300),
  ('studio', '', 350, 350);
INSERT 0 13
INSERT INTO ROOMS
  (ROOMTYPE_ID, NUMBER, FLOOR)
VALUES
  (1, 309, 3),
  (1, 509, 5),
  (1, 710, 7),
  (1, 711, 7),
  (1, 712, 7),
  (3, 308, 3),
  (3, 307, 3),
  (3, 407, 4),
  (3, 507, 5),
  (3, 607, 6),
  (2, 707, 7),
  (2, 605, 6),
  (2, 207, 2),
  (4, 201, 2),
  (4, 202, 2),
  (4, 203, 2),
  (4, 205, 2),
  (4, 206, 2),
  (4, 301, 3),
  (4, 302, 3),
  (4, 303, 3),
  (4, 305, 3),
  (4, 306, 3),
  (8, 310, 3),
  (7, 311, 3),
  (4, 401, 4),
  (4, 402, 4),
  (4, 403, 4),
  (4, 405, 4),
  (4, 406, 4),
  (5, 408, 4),
  (5, 411, 4),
  (4, 501, 5),
  (4, 502, 5),
  (4, 503, 5),
  (4, 505, 5),
  (4, 506, 5),
  (5, 508, 5),
  (4, 601, 6),
  (4, 602, 6),
  (4, 603, 6),
  (4, 606, 6),
  (4, 701, 7),
  (4, 705, 7),
  (4, 706, 7),
  (4, 708, 7),
  (8, 510, 5),
  (7, 511, 5),
  (7, 704, 7),
  (9, 304, 3),
  (9, 504, 5),
  (9, 604, 6),
  (10, 204, 2),
  (10, 404, 4),
  (12, 410, 4),
  (12, 702, 7),
  (13, 132, 7);
INSERT 0 57
INSERT INTO TAXES
  (LABEL, PERCENTAGE, STARTDATE, ENDDATE)
VALUES
  ('0%',0.0,null,null),
  ('2,5%',2.5,null,null),
  ('3,8%',3.8,'1996-01-01','2017-01-01'),
  ('8%',8.0,null,null);
INSERT 0 4
INSERT INTO SERVICESFAMILIES
  (LABEL)
VALUES
  ('Arrangement'),
  ('Repas'),
  ('Prestations');
INSERT 0 3
INSERT INTO SERVICESTYPES
  (LABEL, SERVICEFAMILY_ID, VAT_ID, ROOMNEEDED, CODE)
VALUES
  ('Autre',3,1, '1', 1),
  ('Taxe de sjour',1,1, '1', 1),
  ('Accomodation',1,1, '1', 2),
  ('Repas',2,1, '1', 1),
  ('Prestation extra',3,1, '1', 2),
  ('Vente au comptant',3,1, '0', 3);
INSERT 0 6
INSERT INTO SERVICESFIELDS
  (LABEL, SQLTYPE)
VALUES
  ('DISPLAYEDNAME','VARCHAR(100)'),
  ('PRINTEDNAME','VARCHAR(100)'),
  ('PRICEMIN','DECIMAL'),
  ('PRICEMAX','DECIMAL');
INSERT 0 4
INSERT INTO SERVICES
  (ID, SERVICETYPE_ID, NAME, ISAVAILABLE, CODE)
VALUES
  (-1, 1, 'Autre...', '1', 1),
  (0, 1, 'Autre', '1', 2);
INSERT 0 2
INSERT INTO SERVICES
  (SERVICETYPE_ID, NAME, ISAVAILABLE, CODE)
VALUES
  (2, 'Taxe de sjour adulte', '1', 1),
  (2, 'Taxe de sjour enfant', '1', 2),
  (3, 'Logement', '1', 1),
  (3, 'Logement et petit-djeuner','1', 2),
  (3, 'Arrangement demi-pension', '1', 3),
  (3, 'Arrangement pension complte','1', 4),
  (4, 'Demi-pension', '1', 1),
  (4, 'Pension complte','1', 2),
  (4, 'Restaurant','1',3),
  (4, 'Bistro','1', 4),
  (5, 'Petit-djeuner','1', 1),
  (5, 'Extras petit-djeuner','1',2),
  (5, 'Fax','1', 3),
  (5, 'Garage', '1', 4),
  (5, 'Tlphone','1', 5),
  (5, 'Wifi chambre','0', 6),
  (5, 'Lingerie','1', 7),
  (5, 'Service en chambre','1', 8),
  (6, 'Timbre', '1', 1),
  (6, 'Location salle','1', 2),
  (6, 'Dbours', '1', 3),
  (6, 'Rabais', '1', 4);
INSERT 0 22
INSERT INTO SERVICESDETAILS
  (SERVICE_ID,SERVICEFIELD_ID, FIELDVALUE)
VALUES
  (-1,1,'Autre...'),
  (-1,2,'Autre...'),
  (-1,3,'0'),
  (-1,4,'0'),
  (0, 1,'Autre'),
  (0, 2,'Autre'),
  (0, 3,'0'),
  (0, 4,'0'),
  (1,1,'Taxe de sjour adulte'),
  (1,2,'Taxe de sjour adulte'),
  (1,3,'2'),
  (1,4,'2'),
  (2,1,'Taxe de sjour enfant'),
  (2,2,'Taxe de sjour enfant'),
  (2,3,'1'),
  (2,4,'1'),
  (3,1,'Logement'),
  (3,2,'Logement'),
  (3,3,'-1'),
  (3,4,'-1'),
  (4,1,'Logement et petit-djeuner'),
  (4,2,'Logement+p.dej'),
  (4,3,'-1'),
  (4,4,'-1'),
  (5,1,'Arrangement demi-pension'),
  (5,2,'Arrangement 1/2 pension'),
  (5,3,'-1'),
  (5,4,'-1'),
  (6,1,'Arrangement pension complte'),
  (6,2,'Arrangement pension comp.'),
  (6,3,'-1'),
  (6,4,'-1'),
  (7,1,'Demi-pension'),
  (7,2,'1/2 pension'),
  (7,3,'25'),
  (7,4,'25'),
  (8,1,'Pension complte'),
  (8,2,'Pension complte'),
  (8,3,'50'),
  (8,4,'50'),
  (9,1,'Petit-djeuner'),
  (9,2,'Petit-djeuner'),
  (9,3,'0'),
  (9,4,'0'),
  (10,1,'Extras petit-djeuner'),
  (10,2,'Extras p.dej'),
  (10,3,'0'),
  (10,4,'0'),
  (11,1,'Restaurant'),
  (11,2,'Restaurant'),
  (11,3,'0'),
  (11,4,'0'),
  (12,1,'Bistro'),
  (12,2,'Bistro'),
  (12,3,'0'),
  (12,4,'0'),
  (13,1,'Fax'),
  (13,2,'Fax'),
  (13,3,'0'),
  (13,4,'0'),
  (14,1,'Garage'),
  (14,2,'Garage'),
  (14,3,'0'),
  (14,4,'0'),
  (15,1,'Tlphone'),
  (15,2,'Tlphone'),
  (15,3,'0'),
  (15,4,'0'),
  (16,1,'Wifi chambre'),
  (16,2,'Wifi chambre'),
  (16,3,'5'),
  (16,4,'5'),
  (17,1,'Timbre'),
  (17,2,'Timbre'),
  (17,3,'0'),
  (17,4,'0'),
  (18,1,'Lingerie'),
  (18,2,'Lingerie'),
  (18,3,'0'),
  (18,4,'0'),
  (19,1,'Location salle'),
  (19,2,'Location salle'),
  (19,3,'0'),
  (19,4,'0'),
  (20,1,'Dbours'),
  (20,2,'Dbours'),
  (20,3,'0'),
  (20,4,'0'),
  (21,1,'Rabais'),
  (21,2,'Rabais'),
  (21,3,'0'),
  (21,4,'0'),
  (22,1,'Service en chambre'),
  (22,2,'Service en chambre'),
  (22,3,'0'),
  (22,4,'0');
INSERT 0 96
INSERT INTO USERS
  (LOGIN, ENCRYPTEDPASS, ISRECEPTIONIST, ISMANAGERX, ISMANAGERZ, ISADMINISTRATOR)
VALUES
  ('hotel','EE26B0DD4AF7E749AA1A8EE3C10AE9923F618980772E473F8819A5D4940E0DB27AC185F8A0E1D5F84F88BC887FD67B143732C304CC5FA9AD8E6F57F50028A8FF','1','0','0','0'),
 ('manX','EE26B0DD4AF7E749AA1A8EE3C10AE9923F618980772E473F8819A5D4940E0DB27AC185F8A0E1D5F84F88BC887FD67B143732C304CC5FA9AD8E6F57F50028A8FF','1','1','0','0'),
 ('manZ','EE26B0DD4AF7E749AA1A8EE3C10AE9923F618980772E473F8819A5D4940E0DB27AC185F8A0E1D5F84F88BC887FD67B143732C304CC5FA9AD8E6F57F50028A8FF','1','1','1','0'),
 ('admin','EE26B0DD4AF7E749AA1A8EE3C10AE9923F618980772E473F8819A5D4940E0DB27AC185F8A0E1D5F84F88BC887FD67B143732C304CC5FA9AD8E6F57F50028A8FF','0','0','1','1');
INSERT 0 4
INSERT INTO TRAINEES
  (LOGIN, ENCRYPTEDPASS, ISACTIVATED)
VALUES
  ('formation','EE26B0DD4AF7E749AA1A8EE3C10AE9923F618980772E473F8819A5D4940E0DB27AC185F8A0E1D5F84F88BC887FD67B143732C304CC5FA9AD8E6F57F50028A8FF', '1');
INSERT 0 1
INSERT INTO REPORTSTYPES
  (LABEL, DESCRIPTION, GENERATIONQUERY)
VALUES
  ('today balance','Comptabilisateurs journaliers', 'SELECT dbalance, ddaylog, dmonthlog, dyearlog FROM dailybalcount GROUP BY dyearlog, dmonthlog, ddaylog HAVING dcreationtime = (SELECT MAX(dcreationtime) FROM dailybalcount);'),
  ('total balance','Journal des comptabilisateurs', 'SELECT balance, hourlog, daylog, monthlog, yearlog FROM balance_archiveORDER BY yearlog, monthlog, daylog, hourlog;');
INSERT 0 2


_______________________

k=6





/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/6-*Tous-pgSQL.sql






/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/6-*Archives-pgSQL.sql






/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/6-dbCrea-View-BillingsInfosMain-pgSQL.sql

CREATE VIEW BILLINGSINFOS AS
  SELECT
	BILLINGS.ID AS ID,
	CLIENTS.NAME AS CLIENT,
	ROOMDESC,
	CAST((CASE WHEN BILLINGS.NBADULTS IS NULL THEN 0 WHEN BILLINGS.NBCHILDREN IS NULL THEN 0 ELSE CAST(CAST(BILLINGS.NBADULTS AS INTEGER)+CAST(BILLINGS.NBCHILDREN AS INTEGER) AS INTEGER) END) AS INTEGER) AS NBPEOPLE,
	BILLINGS.ARRIVINGDATE AS ARRIVINGDATE,
	BILLINGS.DEPARTUREDATE AS DEPARTUREDATE,
	BILLINGS.EXPECTEDDEPARTUREDATE AS EXPECTEDDEPARTUREDATE,
	BILLINGSTYPES.LABEL AS TYPE
  FROM BILLINGS
  LEFT JOIN ROOMSOCCUPATIONS ON ROOMSOCCUPATIONS.BILLING_ID = BILLINGS.ID
  LEFT JOIN (
	  SELECT
		ROOMS.ID,
		(ROOMS.NUMBER || '(' || ROOMSTYPES.LABEL || ')') AS ROOMDESC
	  FROM ROOMS
	  LEFT JOIN ROOMSTYPES ON ROOMS.ROOMTYPE_ID = ROOMSTYPES.ID
	) AS R ON R.ID = ROOMSOCCUPATIONS.ROOM_ID
  LEFT JOIN BILLINGSGROUPS ON BILLINGSGROUPS.BILLING_ID = BILLINGS.ID
  LEFT JOIN BILLINGSCLIENTS ON BILLINGSCLIENTS.BILLING_ID = BILLINGS.ID
  LEFT JOIN CLIENTS_ARCHIVE AS CLIENTS ON CLIENTS.ID = BILLINGSCLIENTS.CLIENT_ID
  LEFT JOIN GROUPS_ARCHIVE AS GROUPS ON GROUPS.ID = BILLINGSGROUPS.GROUP_ID
  LEFT JOIN BILLINGSTYPES ON BILLINGSTYPES.ID = BILLINGS.BILLINGSTYPE_ID
  WHERE BILLINGS.ISCLOSED = '0'
  ORDER BY BILLINGS.ARRIVINGDATE;
CREATE VIEW
--WITH CASCADED CHECK OPTION;
CREATE OR REPLACE FUNCTION billingsinfos_up_del()
RETURNS TRIGGER
AS $$
   BEGIN
IF TG_OP = 'UPDATE' THEN
	  SELECT genupsert_billings(hstore(ARRAY[['ARRIVINGDATE','new.ARRIVINGDATE'],['DEPARTUREDATE','new.DEPARTUREDATE'],['EXPECTEDDEPARTUREDATE','new.EXPECTEDDEPARTUREDATE'],['BILLINGSTYPE_ID','(SELECT ID FROM BILLINGSTYPES WHERE LABEL=NEW.TYPE)'],['id','new.id']]));
	  --UPDATE billings SET ARRIVINGDATE=new.ARRIVINGDATE, DEPARTUREDATE=new.DEPARTUREDATE, EXPECTEDDEPARTUREDATE=new.EXPECTEDDEPARTUREDATE, BILLINGSTYPE_ID=(SELECT ID FROM BILLINGSTYPES WHERE LABEL=NEW.TYPE) WHERE ID=new.ID;

	  UPDATE billingsclients SET CLIENT_ID=(SELECT ID FROM CLIENTS_ARCHIVE WHERE NAME=NEW.CLIENT) WHERE billing_id=new.id;

	  ELSIF TG_OP = 'DELETE' THEN
	UPDATE billings SET ISCLOSED='1' WHERE ID=old.ID;
	   RETURN NULL;

	  END IF;
	  RETURN NEW;
	END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION
CREATE TRIGGER tr_changebillingsinfos
	INSTEAD OF UPDATE OR DELETE ON BILLINGSINFOS
	FOR EACH ROW EXECUTE PROCEDURE billingsinfos_up_del();
CREATE TRIGGER


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/6-dbCrea-View-RoomsInfosMain-pgSQL.sql

CREATE VIEW ROOMSINFOS AS
  SELECT
	ROOMS.ID AS ID,
	ROOMS.NUMBER AS NUMBER,
	ROOMS.FLOOR AS FLOOR,
	ROOMTYPE_ID,
	ROOMSTYPES.LABEL AS TYPE,
	ROOMSTYPES.DESCRIPTION AS DESCRIPTION,
	ROOMSTYPES.PRICEMIN AS PRICEMIN,
	ROOMSTYPES.PRICEMAX AS PRICEMAX,
	ROOMS.ISCLEANED AS ISCLEANED,
	B.ISAVAILABLE AS ISAVAILABLE
  FROM ROOMS
  LEFT JOIN (
  SELECT
		  CAST((CASE WHEN SUM(CASE WHEN ROOMSOCCUPATIONS.DEPARTUREDATE>=CURRENT_DATE THEN 1 ELSE 0 END)>0 THEN '0' ELSE '1' END) AS BOOLEAN) AS ISAVAILABLE,
		  ROOMS.ID AS ROOMID
		FROM ROOMSOCCUPATIONS
		RIGHT JOIN ROOMS ON ROOMS.ID=ROOMSOCCUPATIONS.ROOM_ID
		GROUP BY ROOMS.ID
	) AS B ON ROOMS.ID=B.ROOMID
  LEFT JOIN ROOMSTYPES ON ROOMS.ROOMTYPE_ID=ROOMSTYPES.ID
  ORDER BY ROOMS.NUMBER;
CREATE VIEW
  --WITH CASCADED CHECK OPTION;
CREATE OR REPLACE FUNCTION roomsinfos_ins_up_del()
RETURNS TRIGGER
AS $$
   BEGIN
	  IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
	  IF old.ROOMTYPE_ID=new.ROOMTYPE_ID THEN
		UPDATE ROOMSTYPES SET DESCRIPTION=new.description, PRICEMIN=new.pricemin, PRICEMAX=new.pricemax, label=new.TYPE WHERE id=new.ROOMTYPE_ID;
   ELSE
	  SELECT genupsert_ROOMSTYPES(hstore(ARRAY[['DESCRIPTION','new.DESCRIPTION'],['PRICEMIN','new.PRICEMIN'],['PRICEMAX','new.PRICEMAX'],['label','new.type']]));
	  --INSERT INTO ROOMSTYPES(LABEL, DESCRIPTION, PRICEMIN, PRICEMAX) VALUES(new.TYPE, new.description, new.pricemin, new.pricemax);
END IF;
END IF;

IF TG_OP = 'INSERT' THEN
	  INSERT INTO ROOMS(NUMBER, FLOOR, ROOMTYPE_ID, ISCLEANED) VALUES(new.number,new.floor,(select id from roomstypes where LABEL=new.TYPE), new.ISCLEANED);

  ELSEIF TG_OP = 'UPDATE' THEN
	  UPDATE ROOMS SET FLOOR=new.floor, ROOMTYPE_ID=(select id from roomstypes where LABEL=new.TYPE), ISCLEANED=new.ISCLEANED WHERE number=new.number;

  ELSIF TG_OP = 'DELETE' THEN
		DELETE FROM ROOMS WHERE number=old.number;

	   RETURN NULL;

  END IF;
	  RETURN NEW;
	END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION
CREATE TRIGGER tr_changeroomsinfos
	INSTEAD OF INSERT OR UPDATE OR DELETE ON ROOMSINFOS
	FOR EACH ROW EXECUTE PROCEDURE roomsinfos_ins_up_del();
CREATE TRIGGER


/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/Database/postgresql/6-dbCrea-View-ServicesInfosMain-pgSQL.sql

SELECT genpivotcode('SERVICESDETAILS', 'SERVICE_ID', 'LABEL', 'FIELDVALUE', 'SQLTYPE', 'SERVICESFIELDS', 'SERVICEFIELD_ID', 'INTEGER', 'SERVICESDETAILSPIVOT');
                                                                                                                                                                                                                         genpivotcode                                                                                                                                                                                                                          
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE TABLE SERVICESDETAILSPIVOT AS (SELECT * FROM crosstab ('SELECT SERVICE_ID, SERVICEFIELD_ID, string_agg(FIELDVALUE,'','') FROM SERVICESDETAILS GROUP BY SERVICE_ID,SERVICEFIELD_ID ORDER BY SERVICE_ID,SERVICEFIELD_ID', 'SELECT DISTINCT SERVICEFIELD_ID FROM  SERVICESDETAILS ORDER BY SERVICEFIELD_ID') AS SERVICESDETAILSPIVOT (SERVICE_ID INTEGER, _DISPLAYEDNAME VARCHAR(100), _PRINTEDNAME VARCHAR(100), _PRICEMIN DECIMAL, _PRICEMAX DECIMAL));
(1 ligne)

CREATE VIEW SERVICESINFOS AS
  SELECT
	SERVICES.ID AS ID,
	SERVICEFAMILY_ID||''||SERVICESTYPES.CODE||''||SERVICES.CODE AS SERVICEFULLCODE,
	SERVICESDETAILSPIVOT.*,
	SERVICES.CODE AS SERVICECODE,
	SERVICES.NAME AS SERVICENAME,
	SERVICESFAMILIES.LABEL AS SERVICEFAMILY,
	SERVICESTYPES.LABEL AS SERVICETYPE,
	TAXES.LABEL AS VAT,
	SERVICES.ISAVAILABLE AS ISAVAILABLE,
	VAT_ID,
	SERVICEFAMILY_ID,
	SERVICETYPE_ID,
	SERVICESTYPES.ROOMNEEDED AS TYPENEEDSROOM
  FROM SERVICES
  LEFT JOIN SERVICESTYPES ON SERVICES.SERVICETYPE_ID=SERVICESTYPES.ID
  LEFT JOIN SERVICESFAMILIES ON SERVICESTYPES.SERVICEFAMILY_ID=SERVICESFAMILIES.ID
  LEFT JOIN SERVICESDETAILSPIVOT ON SERVICESDETAILSPIVOT.SERVICE_ID=SERVICES.ID
  LEFT JOIN TAXES ON SERVICESTYPES.VAT_ID = TAXES.ID
  ORDER BY SERVICEFAMILY, SERVICETYPE, SERVICENAME;--,
CREATE VIEW
  --GROUP BY SERVICES.ID--;
  --WITH CASCADED CHECK OPTION;
CREATE OR REPLACE FUNCTION servicesinfos_ins_up_del()
RETURNS TRIGGER
AS $$
   BEGIN
   IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
	  IF old.SERVICEFAMILY_ID=new.SERVICEFAMILY_ID THEN
		UPDATE SERVICESFAMILIES SET LABEL=new.SERVICEFAMILY WHERE id=new.SERVICEFAMILY_ID;
	  ELSE
		INSERT INTO SERVICESFAMILIES(LABEL) VALUES(new.SERVICEFAMILY);
	  END IF;

	  IF old.SERVICETYPE_ID=new.SERVICETYPE_ID THEN
		UPDATE SERVICESTYPES SET LABEL=new.SERVICETYPE WHERE id=new.SERVICETYPE_ID;
	  ELSE
		SELECT genupsert_SERVICESTYPES(hstore(ARRAY[['LABEL','new.SERVICETYPE'],['SERVICEFAMILY_ID','(SELECT id FROM SERVICESFAMILIES WHERE LABEL=new.SERVICEFAMILY)'],['VAT_ID','new.VAT_ID'],['ROOMNEEDED','new.TYPENEEDSROOM']]));
		--INSERT INTO SERVICESTYPES(LABEL, SERVICEFAMILY_ID, VAT_ID, ROOMNEEDED) VALUES(new.SERVICETYPE, (SELECT id FROM SERVICESFAMILIES WHERE LABEL=new.SERVICEFAMILY), new.VAT_ID, new.TYPENEEDSROOM);
	  END IF;
	END IF;

-- TODO: upsert details (got from SERVICESDETAILSPIVOT) in SERVICESDETAILS

  IF TG_OP = 'INSERT' THEN
	  INSERT INTO SERVICES(SERVICETYPE_ID, NAME, ISAVAILABLE) VALUES((SELECT id FROM SERVICESFAMILIES WHERE LABEL=new.SERVICETYPE),new.SERVICENAME,new.ISAVAILABLE);
  ELSEIF TG_OP = 'UPDATE' THEN
	  --UPDATE ROOMS SET FLOOR=new.floor, ROOMTYPE_ID=(select id from roomstypes where LABEL=new.TYPE) WHERE number=new.number; //TODO
	  ELSIF TG_OP = 'DELETE' THEN
		DELETE FROM SERVICES WHERE name=old.servicename;
	   RETURN NULL;
   END IF;

	  RETURN NEW;
	END;
$$ LANGUAGE plpgsql;
CREATE FUNCTION
CREATE TRIGGER tr_changeservicesinfos
	INSTEAD OF INSERT OR UPDATE OR DELETE ON SERVICESINFOS
	FOR EACH ROW EXECUTE PROCEDURE servicesinfos_ins_up_del();
CREATE TRIGGER
