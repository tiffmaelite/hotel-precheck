CREATE TABLE BOOKINGS
(
  ID SERIAL,
  CLIENT_ID INTEGER NOT NULL,
  ROOMTYPE_ID INTEGER NOT NULL,
  NBADULTS SMALLINT DEFAULT 0,
  NBCHILDREN SMALLINT DEFAULT 0,
  EXPECTEDARRIVINGDATE DATE NOT NULL,
  EXPECTEDDEPARTUREDATE DATE NOT NULL,
  BOOKINGDATE DATE NOT NULL,
  CONFIRMATIONDATE DATE,
  CANCELATIONDATE DATE,
  NOTE VARCHAR(255),
  CONSTRAINT PK_BOOKINGS_ID PRIMARY KEY (ID),
  CONSTRAINT UQ_BOOKINGS_CLIENTARRIVING UNIQUE (CLIENT_ID,EXPECTEDARRIVINGDATE),
  CONSTRAINT UQ_BOOKINGS_CLIENTDEPARTURE UNIQUE (CLIENT_ID,EXPECTEDDEPARTUREDATE),
  CONSTRAINT CK_POS_BOOKINGS_NBADULTS CHECK (NBADULTS >= 0),
  CONSTRAINT CK_POS_BOOKINGS_NBCHILDREN CHECK (NBCHILDREN >= 0)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);

--CREATE TRIGGER z__minupdate_BOOKINGS
--BEFORE UPDATE ON BOOKINGS
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();

CREATE OR REPLACE FUNCTION  fkBOOKINGSreferencesclientsarchives() RETURNS TRIGGER AS $$
BEGIN
IF (NOT EXISTS (SELECT 1 FROM CLIENTS_ARCHIVE WHERE ID = new.CLIENT_ID)) THEN
RAISE EXCEPTION 'Foreign key exception!';
END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tr_fkBOOKINGSreferencesclientsarchives BEFORE INSERT OR UPDATE ON BOOKINGS
FOR EACH ROW
EXECUTE PROCEDURE fkBOOKINGSreferencesclientsarchives();


CREATE OR REPLACE FUNCTION  upsert_BOOKINGS(newinput hstore) RETURNS VOID AS $inner$
BEGIN
WITH upsert1 AS (
	UPDATE BOOKINGS SET ROOMTYPE_ID=newinput -> 'ROOMTYPE_ID', EXPECTEDDEPARTUREDATE=newinput -> 'EXPECTEDDEPARTUREDATE', NBADULTS=newinput -> 'NBADULTS', NBCHILDREN=newinput -> 'NBCHILDREN', BOOKINGDATE=newinput -> 'BOOKINGDATE', CONFIRMATIONDATE=newinput -> 'CONFIRMATIONDATE', CANCELATIONDATE=newinput -> 'CANCELATIONDATE', NOTE=newinput -> 'NOTE' WHERE CLIENT_ID=newinput -> 'CLIENT_ID' AND EXPECTEDARRIVINGDATE=newinput -> 'EXPECTEDARRIVINGDATE' RETURNING BOOKINGS.*
  ), upsert2 AS (
	UPDATE BOOKINGS SET ROOMTYPE_ID=newinput -> 'ROOMTYPE_ID', EXPECTEDARRIVINGDATE=newinput -> 'EXPECTEDARRIVINGDATE', NBADULTS=newinput -> 'NBADULTS', NBCHILDREN=newinput -> 'NBCHILDREN', BOOKINGDATE=newinput -> 'BOOKINGDATE', CONFIRMATIONDATE=newinput -> 'CONFIRMATIONDATE', CANCELATIONDATE=newinput -> 'CANCELATIONDATE', NOTE=newinput -> 'NOTE' WHERE CLIENT_ID=newinput -> 'CLIENT_ID' AND EXPECTEDDEPARTUREDATE=newinput -> 'EXPECTEDDEPARTUREDATE' RETURNING BOOKINGS.*
  )
INSERT INTO BOOKINGS (
  SELECT * FROM BOOKINGS
	WHERE NOT EXISTS (
	SELECT 1 FROM upsert1 b1 WHERE (CLIENT_ID=b1.CLIENT_ID AND EXPECTEDARRIVINGDATE=b1.EXPECTEDARRIVINGDATE)
	  UNION ALL SELECT 1 FROM upsert2 b2 WHERE (CLIENT_ID=b2.CLIENT_ID AND EXPECTEDDEPARTUREDATE=b2.EXPECTEDDEPARTUREDATE)
	)
  );
END;
$inner$ LANGUAGE plpgsql;




CREATE TABLE TRAINING_BOOKINGS
(
  ID SERIAL,
  CLIENT_ID INTEGER NOT NULL,
  ROOMTYPE_ID INTEGER NOT NULL,
  NBADULTS SMALLINT DEFAULT 0,
  NBCHILDREN SMALLINT DEFAULT 0,
  EXPECTEDARRIVINGDATE DATE NOT NULL,
  EXPECTEDDEPARTUREDATE DATE NOT NULL,
  BOOKINGDATE DATE NOT NULL,
  CONFIRMATIONDATE DATE,
  CANCELATIONDATE DATE,
  NOTE VARCHAR(255),
  CONSTRAINT PK_TRAININGBOOKINGS_ID PRIMARY KEY (ID),
  CONSTRAINT UQ_TRAININGBOOKINGS_CLIENTARRIVING UNIQUE (CLIENT_ID,EXPECTEDARRIVINGDATE),
  CONSTRAINT UQ_TRAININGBOOKINGS_CLIENTDEPARTURE UNIQUE (CLIENT_ID,EXPECTEDDEPARTUREDATE),
  CONSTRAINT CK_POS_TRAININGBOOKINGS_NBADULTS CHECK (NBADULTS >= 0),
  CONSTRAINT CK_POS_TRAININGBOOKINGS_NBCHILDREN CHECK (NBCHILDREN >= 0)
) WITH (autovacuum_enabled = 'true', autovacuum_vacuum_threshold = 5);

--suppress_redundant_updates_trigger(); incompatible with upserts!!!
--CREATE TRIGGER z__minupdate_TRAININGBOOKINGS
--BEFORE UPDATE ON TRAINING_BOOKINGS
--FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();

CREATE OR REPLACE FUNCTION  fktrainingbookingsreferencesclientsarchives() RETURNS TRIGGER AS $$
BEGIN
IF (NOT EXISTS (SELECT 1 FROM CLIENTS_ARCHIVE WHERE ID = new.CLIENT_ID)) THEN
RAISE EXCEPTION 'Foreign key exception!';
END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tr_fktrainingbookingsreferencesclientsarchives BEFORE INSERT OR UPDATE ON training_bookings
FOR EACH ROW
EXECUTE PROCEDURE fktrainingbookingsreferencesclientsarchives();


CREATE OR REPLACE FUNCTION  upsert_trainingbookings() RETURNS VOID AS $inner$
BEGIN
WITH upsert1 AS (
	UPDATE training_bookings SET ROOMTYPE_ID=newinput -> 'ROOMTYPE_ID', EXPECTEDDEPARTUREDATE=newinput -> 'EXPECTEDDEPARTUREDATE', NBADULTS=newinput -> 'NBADULTS', NBCHILDREN=newinput -> 'NBCHILDREN', BOOKINGDATE=newinput -> 'BOOKINGDATE', CONFIRMATIONDATE=newinput -> 'CONFIRMATIONDATE', CANCELATIONDATE=newinput -> 'CANCELATIONDATE', NOTE=newinput -> 'NOTE' WHERE CLIENT_ID=newinput -> 'CLIENT_ID' AND EXPECTEDARRIVINGDATE=newinput -> 'EXPECTEDARRIVINGDATE' RETURNING BOOKINGS.*
  ), upsert2 AS (
	UPDATE training_bookings SET ROOMTYPE_ID=newinput -> 'ROOMTYPE_ID', EXPECTEDARRIVINGDATE=newinput -> 'EXPECTEDARRIVINGDATE', NBADULTS=newinput -> 'NBADULTS', NBCHILDREN=newinput -> 'NBCHILDREN', BOOKINGDATE=newinput -> 'BOOKINGDATE', CONFIRMATIONDATE=newinput -> 'CONFIRMATIONDATE', CANCELATIONDATE=newinput -> 'CANCELATIONDATE', NOTE=newinput -> 'NOTE' WHERE CLIENT_ID=newinput -> 'CLIENT_ID' AND EXPECTEDDEPARTUREDATE=newinput -> 'EXPECTEDDEPARTUREDATE' RETURNING BOOKINGS.*
  )
INSERT INTO training_bookings (
  SELECT * FROM training_bookings
	WHERE NOT EXISTS (
	SELECT 1 FROM upsert1 b1 WHERE (CLIENT_ID=b1.CLIENT_ID AND EXPECTEDARRIVINGDATE=b1.EXPECTEDARRIVINGDATE)
	  UNION ALL SELECT 1 FROM upsert2 b2 WHERE (CLIENT_ID=b2.CLIENT_ID AND EXPECTEDDEPARTUREDATE=b2.EXPECTEDDEPARTUREDATE)
	)
  );
END;
$inner$ LANGUAGE plpgsql;
