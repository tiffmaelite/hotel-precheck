.TH "SH_DatabaseManager" 3 "Lundi Juin 24 2013" "Version 0.4" "PreCheck" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SH_DatabaseManager \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <SH_DatabaseManager\&.h>\fP
.PP
Est dérivée de \fBQObject\fP\&.
.SS "Fonctions membres publiques"

.in +1c
.ti -1c
.RI "\fB~SH_DatabaseManager\fP ()"
.br
.ti -1c
.RI "int \fBdataCount\fP (QString tableName, QString filter)"
.br
.ti -1c
.RI "bool \fBdbConnect\fP ()"
.br
.ti -1c
.RI "bool \fBdbDisconnect\fP ()"
.br
.ti -1c
.RI "QVariant \fBexecInsertReturningQuery\fP (QString tableName, QVariantMap values, QString returningField)"
.br
.ti -1c
.RI "bool \fBexecReplaceQuery\fP (QString tableName, QVariantMap values)"
.br
.ti -1c
.RI "QSqlQuery \fBexecSelectQuery\fP (QString tableName, QStringList fields=QStringList('*'), QString condition='', QString ordering='')"
.br
.ti -1c
.RI "QSqlDatabase \fBgetDbConnection\fP ()"
.br
.ti -1c
.RI "bool \fBisConnected\fP ()"
.br
.ti -1c
.RI "bool \fBtableExists\fP (QString tableName)"
.br
.in -1c
.SS "Fonctions membres publiques statiques"

.in +1c
.ti -1c
.RI "static \fBSH_DatabaseManager\fP * \fBgetInstance\fP ()"
.br
.in -1c
.SS "Fonctions membres protégées"

.in +1c
.ti -1c
.RI "\fBSH_DatabaseManager\fP ()"
.br
.in -1c
.SS "Attributs protégés"

.in +1c
.ti -1c
.RI "QSqlDatabase \fBdbConnection\fP"
.br
.RI "\fIdbConnection \fP"
.in -1c
.SS "Fonctions membres privées"

.in +1c
.ti -1c
.RI "void \fBdivideQVariantMap\fP (QVariantMap values, QString &fields, QString &vals)"
.br
.in -1c
.SS "Attributs privés statiques"

.in +1c
.ti -1c
.RI "static \fBSH_DatabaseManager\fP * \fB_instance\fP = 0"
.br
.RI "\fI_instance \fP"
.in -1c
.SH "Description détaillée"
.PP 
Définition à la ligne 63 du fichier SH_DatabaseManager\&.h\&.
.SH "Documentation des constructeurs et destructeur"
.PP 
.SS "SH_DatabaseManager::SH_DatabaseManager ()\fC [protected]\fP"

.PP
Définition à la ligne 40 du fichier SH_DatabaseManager\&.cpp\&.
.PP
Références dbConnect(), dbConnection, dbDriverNotExistStr, dbDriverStr, dbFileNameStr, dbFilePathStr, dbPasswordStr, dbUsernameStr, et SH_MessageManager::errorMessage()\&.
.PP
Référencé par getInstance()\&.
.PP
.nf
41 {
42     /*
43      *Check the existence of the database driver\&.
44      */
45     if (!QSqlDatabase::isDriverAvailable(dbDriverStr))
46     {
47         /*
48         *Gui message that informs that the driver does not exist
49         */
50         SH_MessageManager::errorMessage(dbDriverNotExistStr);
51         qDebug() << dbConnection\&.lastError();
52         for (int i = 0; i < dbConnection\&.drivers()\&.count(); i++)
53         {
54             qDebug() << "AVAILABLE DRIVERS : " << dbConnection\&.drivers()[i] << endl;
55         }
56         exit(1);
57     }
58 
59     /*
60     *Connect to the database with the following driver\&.
61     */
62     dbConnection = QSqlDatabase::addDatabase(dbDriverStr);
63     if (dbDriverStr == "QIBASE")
64     {
65         dbConnection\&.setDatabaseName(dbFilePathStr);
66     } else {
67         dbConnection\&.setDatabaseName(dbFileNameStr);
68     }
69 
70     dbConnection\&.setUserName(dbUsernameStr);
71     dbConnection\&.setPassword(dbPasswordStr);
72     dbConnect();
73 
74 }
.fi
.SS "SH_DatabaseManager::~SH_DatabaseManager ()"

.PP
Définition à la ligne 29 du fichier SH_DatabaseManager\&.cpp\&.
.PP
Références dbDisconnect()\&.
.PP
.nf
30 {
31     dbDisconnect();
32 }
.fi
.SH "Documentation des fonctions membres"
.PP 
.SS "int SH_DatabaseManager::dataCount (QStringtableName, QStringfilter)"

.PP
Définition à la ligne 166 du fichier SH_DatabaseManager\&.cpp\&.
.PP
Références dbConnection, et execSelectQuery()\&.
.PP
.nf
166                                                                    {
167     if(!tableName\&.isEmpty() && !filter\&.isEmpty()) {
168         QSqlQuery result = execSelectQuery(tableName, QStringList("COUNT(*) AS MATCH"), filter);
169         if(dbConnection\&.driver()->hasFeature(QSqlDriver::QuerySize)) {
170             return result\&.size();
171         } else {
172             if(result\&.next()) {
173                 QSqlRecord rec = result\&.record();
174                 if(!rec\&.isEmpty()  && result\&.isValid()) {
175                     return rec\&.value(rec\&.indexOf("MATCH"))\&.toInt();
176                 }
177             }
178         }
179     }
180     return 0;
181 }
.fi
.SS "SH_DatabaseManager::dbConnect ()"

.PP
\fBRenvoie:\fP
.RS 4
bool 
.RE
.PP

.PP
Définition à la ligne 85 du fichier SH_DatabaseManager\&.cpp\&.
.PP
Références dbCannotOpenStr, dbConnection, et SH_MessageManager::errorMessage()\&.
.PP
Référencé par SH_DatabaseManager()\&.
.PP
.nf
86 {
87     /*
88             *Open database, if the database cannot open for
89             *any reason print a warning\&.
90             */
91     if (!dbConnection\&.open())
92     {
93         /*
94                  *Gui message that informs that the database cannot open
95                  */
96         SH_MessageManager::errorMessage(dbCannotOpenStr);
97         qDebug() << dbConnection\&.lastError();
98 
99         /*
100                  *@return false if database connection failed\&.
101                  */
102         return false;
103     }
104 
105     /*
106              *@return true if database connection successed
107              */
108     return dbConnection\&.isOpen();
109 }
.fi
.SS "SH_DatabaseManager::dbDisconnect ()"

.PP
\fBRenvoie:\fP
.RS 4
bool 
.RE
.PP

.PP
Définition à la ligne 120 du fichier SH_DatabaseManager\&.cpp\&.
.PP
Références dbConnection\&.
.PP
Référencé par ~SH_DatabaseManager()\&.
.PP
.nf
121 {
122     /*
123              *close database
124              */
125     dbConnection\&.close();
126     return (!dbConnection\&.isOpen());
127 }
.fi
.SS "SH_DatabaseManager::divideQVariantMap (QVariantMapvalues, QString &fields, QString &vals)\fC [private]\fP"

.PP
\fBParamètres:\fP
.RS 4
\fIvalues\fP 
.br
\fIou]\fP fields 
.br
\fIou]\fP vals 
.RE
.PP

.PP
Définition à la ligne 256 du fichier SH_DatabaseManager\&.cpp\&.
.PP
Référencé par execInsertReturningQuery(), et execReplaceQuery()\&.
.PP
.nf
256                                                                                              {
257     for(auto field : values\&.keys())
258     {
259         fields += field+",";
260         QVariant val = values\&.value(field);
261         bool ok;
262         int intVal = val\&.toInt(&ok);
263         if(ok) {
264             vals += QString::number(intVal)+",";
265         }
266         double dbVal = val\&.toDouble(&ok);
267         if(ok) {
268             vals += QString::number(dbVal)+",";
269         }
270         /*bool boolVal = val\&.toBool();
271                 if(boolVal) {
272                     &vals += "'"+1+"'',";
273                 }*/
274         QDate dateVal = val\&.toDate();
275         if(dateVal\&.isValid()) {
276             vals += "'"+dateVal\&.toString()+"'',"; /*FIXME adapt date format*/
277         }
278         QDateTime dateTimeVal = val\&.toDateTime();
279         if(dateTimeVal\&.isValid()) {
280             vals += "'"+dateTimeVal\&.toString()+"'',"; /*FIXME adapt datetime format*/
281         }
282         QString stringVal = val\&.toString();
283         vals += "'"+stringVal+"'',";
284     }
285     fields = fields\&.left(fields\&.lastIndexOf(',')-1);
286     vals = vals\&.left(vals\&.lastIndexOf(',')-1);
287 }
.fi
.SS "SH_DatabaseManager::execInsertReturningQuery (QStringtableName, QVariantMapvalues, QStringreturningField)"

.PP
\fBParamètres:\fP
.RS 4
\fIquery\fP 
.br
\fIreturningField\fP 
.RE
.PP
\fBRenvoie:\fP
.RS 4
QVariant 
.RE
.PP

.PP
Définition à la ligne 233 du fichier SH_DatabaseManager\&.cpp\&.
.PP
Références dbConnection, et divideQVariantMap()\&.
.PP
Référencé par SH_AdaptDatabaseState::insertUpdate()\&.
.PP
.nf
233                                                                                                                    {
234     QString fields;
235     QString vals;
236     divideQVariantMap(values, fields, vals);
237     QString query;
238     if(dbConnection\&.driverName() == "QIBASE") {
239         query = QString("UPDATE OR INSERT INTO %1(%2) VALUES(%3) MATCHING(ID) RETURNING %4")\&.arg(tableName)\&.arg(fields)\&.arg(vals)\&.arg(returningField);
240     }
241     QSqlQuery result = dbConnection\&.exec(query);
242     qDebug() << result\&.executedQuery() << " > " << result\&.isValid() <<" "<< result\&.isActive();
243     if(result\&.next()) {
244         QSqlRecord rec = result\&.record();
245         if(!rec\&.isEmpty()  && result\&.isValid()) {
246             return rec\&.value(rec\&.indexOf(returningField));
247         }
248     }
249     return QVariant();
250 }
.fi
.SS "SH_DatabaseManager::execReplaceQuery (QStringtableName, QVariantMapvalues)"

.PP
\fBParamètres:\fP
.RS 4
\fIquery\fP 
.RE
.PP
\fBRenvoie:\fP
.RS 4
bool 
.RE
.PP

.PP
Définition à la ligne 216 du fichier SH_DatabaseManager\&.cpp\&.
.PP
Références dbConnection, et divideQVariantMap()\&.
.PP
.nf
216                                                                                {
217     QString fields;
218     QString vals;
219     divideQVariantMap(values, fields, vals);
220     QString query;
221     if(dbConnection\&.driverName() == "QIBASE") {
222         query = QString("UPDATE OR INSERT INTO %1(%2) VALUES(%3) MATCHING(ID)")\&.arg(tableName)\&.arg(fields)\&.arg(vals);
223     }
224     QSqlQuery result = dbConnection\&.exec(query);
225     qDebug() << result\&.executedQuery() << " > " << result\&.isValid() <<" "<< result\&.isActive();
226     return (result\&.numRowsAffected() > 0);
227 }
.fi
.SS "QSqlQuery SH_DatabaseManager::execSelectQuery (QStringtableName, QStringListfields = \fCQStringList('*')\fP, QStringcondition = \fC''\fP, QStringordering = \fC''\fP)"

.PP
Définition à la ligne 189 du fichier SH_DatabaseManager\&.cpp\&.
.PP
Références dbConnection\&.
.PP
Référencé par dataCount(), SH_SqlDataModel::fetch(), SH_User::logIn(), et SH_ServiceCharging::SH_ServiceCharging()\&.
.PP
.nf
189                                                                                                                         {
190     if(fields\&.isEmpty()) {
191         fields\&.append("*");
192     }
193 
194     QString query;
195     if(dbConnection\&.driverName() == "QIBASE") {
196         query = QString("SELECT %1 FROM %2")\&.arg(fields\&.join(", "))\&.arg(tableName);
197         if(!condition\&.isEmpty()) {
198             query = QString("%1 WHERE %2")\&.arg(query)\&.arg(condition);
199         }
200         if(!ordering\&.isEmpty()) {
201             query = QString("%1 ORDER BY %2")\&.arg(query)\&.arg(ordering);
202         }
203     }
204     qDebug() << query;
205     QSqlQuery result;
206     result\&.exec(query);
207     qDebug() << result\&.executedQuery() << " > " << result\&.isValid() <<" "<< result\&.isActive();
208     return result;
209 }
.fi
.SS "SH_DatabaseManager::getDbConnection ()"

.PP
\fBRenvoie:\fP
.RS 4
QSqlDatabase 
.RE
.PP

.PP
Définition à la ligne 146 du fichier SH_DatabaseManager\&.cpp\&.
.PP
Références dbConnection\&.
.PP
.nf
147 {
148     return dbConnection;
149 }
.fi
.SS "SH_DatabaseManager::getInstance ()\fC [static]\fP"

.PP
\fBRenvoie:\fP
.RS 4
\fBSH_DatabaseManager\fP 
.RE
.PP

.PP
Définition à la ligne 13 du fichier SH_DatabaseManager\&.cpp\&.
.PP
Références _instance, dbFilePathStr, et SH_DatabaseManager()\&.
.PP
Référencé par SH_SqlDataModel::fetch(), SH_AdaptDatabaseState::insertUpdate(), SH_User::logIn(), SH_ServiceCharging::SH_ServiceCharging(), SH_User::traineeExists(), et SH_User::userExists()\&.
.PP
.nf
14 {
15     if (_instance == 0)
16     {
17         _instance = new SH_DatabaseManager;
18     }
19     qDebug() << dbFilePathStr;
20     return _instance;
21 }
.fi
.SS "SH_DatabaseManager::isConnected ()"

.PP
\fBRenvoie:\fP
.RS 4
bool 
.RE
.PP

.PP
Définition à la ligne 135 du fichier SH_DatabaseManager\&.cpp\&.
.PP
Références dbConnection\&.
.PP
.nf
136 {
137     return dbConnection\&.isOpen();
138 }
.fi
.SS "SH_DatabaseManager::tableExists (QStringtableName)"

.PP
\fBParamètres:\fP
.RS 4
\fItableName\fP 
.RE
.PP
\fBRenvoie:\fP
.RS 4
bool 
.RE
.PP

.PP
Définition à la ligne 156 du fichier SH_DatabaseManager\&.cpp\&.
.PP
Références dbConnection\&.
.PP
.nf
157 {
158     return dbConnection\&.tables(QSql::Views)\&.contains(tableName\&.toUpper(), Qt::CaseInsensitive) || dbConnection\&.tables(QSql::Tables)\&.contains(tableName\&.toUpper(), Qt::CaseInsensitive);
159 }
.fi
.SH "Documentation des données membres"
.PP 
.SS "\fBSH_DatabaseManager\fP * SH_DatabaseManager::_instance = 0\fC [static]\fP, \fC [private]\fP"

.PP
_instance 
.PP
Définition à la ligne 70 du fichier SH_DatabaseManager\&.h\&.
.PP
Référencé par getInstance()\&.
.SS "QSqlDatabase SH_DatabaseManager::dbConnection\fC [protected]\fP"

.PP
dbConnection 
.PP
Définition à la ligne 91 du fichier SH_DatabaseManager\&.h\&.
.PP
Référencé par dataCount(), dbConnect(), dbDisconnect(), execInsertReturningQuery(), execReplaceQuery(), execSelectQuery(), getDbConnection(), isConnected(), SH_DatabaseManager(), et tableExists()\&.

.SH "Auteur"
.PP 
Généré automatiquement par Doxygen pour PreCheck à partir du code source\&.
