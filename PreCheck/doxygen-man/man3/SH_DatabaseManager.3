.TH "SH_DatabaseManager" 3 "Mardi Juillet 2 2013" "Version 0.4" "PreCheck" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SH_DatabaseManager \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <SH_DatabaseManager\&.h>\fP
.PP
Est dérivée de \fBQObject\fP\&.
.SS "Fonctions membres publiques"

.in +1c
.ti -1c
.RI "\fB~SH_DatabaseManager\fP ()"
.br
.ti -1c
.RI "int \fBdataCount\fP (QString tableName, QString filter)"
.br
.ti -1c
.RI "bool \fBdbConnect\fP ()"
.br
.ti -1c
.RI "bool \fBdbDisconnect\fP ()"
.br
.ti -1c
.RI "QVariant \fBexecInsertReturningQuery\fP (QString tableName, QVariantMap values, QString returningField)"
.br
.ti -1c
.RI "bool \fBexecReplaceQuery\fP (QString tableName, QVariantMap values)"
.br
.ti -1c
.RI "QSqlQuery \fBexecSelectQuery\fP (QString tableName, QStringList fields=QStringList('*'), QString condition='', QString ordering='')"
.br
.ti -1c
.RI "QSqlDatabase \fBgetDbConnection\fP ()"
.br
.ti -1c
.RI "bool \fBisConnected\fP ()"
.br
.ti -1c
.RI "bool \fBtableExists\fP (QString tableName)"
.br
.in -1c
.SS "Fonctions membres publiques statiques"

.in +1c
.ti -1c
.RI "static \fBSH_DatabaseManager\fP * \fBgetInstance\fP ()"
.br
.in -1c
.SS "Fonctions membres protégées"

.in +1c
.ti -1c
.RI "\fBSH_DatabaseManager\fP ()"
.br
.in -1c
.SS "Attributs protégés"

.in +1c
.ti -1c
.RI "QSqlDatabase \fBdbConnection\fP"
.br
.RI "\fIdbConnection \fP"
.in -1c
.SS "Fonctions membres privées"

.in +1c
.ti -1c
.RI "void \fBdivideQVariantMap\fP (QVariantMap values, QString &fields, QString &vals)"
.br
.in -1c
.SS "Attributs privés statiques"

.in +1c
.ti -1c
.RI "static \fBSH_DatabaseManager\fP * \fB_instance\fP = 0"
.br
.RI "\fI_instance \fP"
.in -1c
.SH "Description détaillée"
.PP 
Définition à la ligne 61 du fichier SH_DatabaseManager\&.h\&.
.SH "Documentation des constructeurs et destructeur"
.PP 
.SS "SH_DatabaseManager::SH_DatabaseManager ()\fC [protected]\fP"

.PP
Définition à la ligne 37 du fichier SH_DatabaseManager\&.cpp\&.
.PP
Références dbConnect(), dbConnection, dbDriverNotExistStr, dbDriverStr, dbFileNameStr, dbFilePathStr, dbPasswordStr, dbUsernameStr, et SH_MessageManager::errorMessage()\&.
.PP
Référencé par getInstance()\&.
.PP
.nf
38 {
39 
40     /*Check the existence of the database driver\&.
41     */
42     if (!QSqlDatabase::isDriverAvailable(dbDriverStr))
43     {
44 
45         /*Gui message that informs that the driver does not exist
46     */
47         SH_MessageManager::errorMessage(dbDriverNotExistStr);
48         SH_MessageManager::errorMessage(dbConnection\&.lastError()\&.text());
49         SH_MessageManager::errorMessage("AVAILABLE DRIVERS: "+dbConnection\&.drivers()\&.join(", "));
50         exit(1);
51     }
52 
53 
54     /*Connect to the database with the following driver\&.
55     */
56     dbConnection = QSqlDatabase::addDatabase(dbDriverStr);
57     if (dbDriverStr == "QIBASE")
58     {
59         dbConnection\&.setDatabaseName(dbFilePathStr);
60     } else {
61         dbConnection\&.setDatabaseName(dbFileNameStr);
62     }
63 
64     dbConnection\&.setUserName(dbUsernameStr);
65     dbConnection\&.setPassword(dbPasswordStr);
66     dbConnect();
67 
68 }
.fi
.SS "SH_DatabaseManager::~SH_DatabaseManager ()"

.PP
Définition à la ligne 27 du fichier SH_DatabaseManager\&.cpp\&.
.PP
Références dbDisconnect()\&.
.PP
.nf
28 {
29     dbDisconnect();
30 }
.fi
.SH "Documentation des fonctions membres"
.PP 
.SS "int SH_DatabaseManager::dataCount (QStringtableName, QStringfilter)"

.PP
Définition à la ligne 152 du fichier SH_DatabaseManager\&.cpp\&.
.PP
Références dbConnection, et execSelectQuery()\&.
.PP
.nf
152                                                                    {
153     if(!tableName\&.isEmpty() && !filter\&.isEmpty()) {
154         QSqlQuery result = execSelectQuery(tableName, QStringList("COUNT(*) AS MATCH"), filter);
155         if(dbConnection\&.driver()->hasFeature(QSqlDriver::QuerySize)) {
156             return result\&.size();
157         } else {
158             if(result\&.next()) {
159                 QSqlRecord rec = result\&.record();
160                 if(!rec\&.isEmpty() && result\&.isValid()) {
161                     return rec\&.value(rec\&.indexOf("MATCH"))\&.toInt();
162                 }
163             }
164         }
165     }
166     return 0;
167 }
.fi
.SS "SH_DatabaseManager::dbConnect ()"

.PP
\fBRenvoie:\fP
.RS 4
bool 
.RE
.PP

.PP
Définition à la ligne 77 du fichier SH_DatabaseManager\&.cpp\&.
.PP
Références dbCannotOpenStr, dbConnection, et SH_MessageManager::errorMessage()\&.
.PP
Référencé par SH_DatabaseManager()\&.
.PP
.nf
78 {
79 
80     /*Open database, if the database cannot open for
81     *any reason print a warning\&.
82     */
83     if (!dbConnection\&.open())
84     {
85 
86         /*Gui message that informs that the database cannot open
87     */
88         SH_MessageManager::errorMessage(dbCannotOpenStr);
89         SH_MessageManager::errorMessage(dbConnection\&.lastError()\&.text());
90 
91 
92         /*@return false if database connection failed\&.
93     */
94         return false;
95     }
96 
97 
98     /*@return true if database connection successed
99     */
100     return dbConnection\&.isOpen();
101 }
.fi
.SS "SH_DatabaseManager::dbDisconnect ()"

.PP
\fBRenvoie:\fP
.RS 4
bool 
.RE
.PP

.PP
Définition à la ligne 110 du fichier SH_DatabaseManager\&.cpp\&.
.PP
Références dbConnection\&.
.PP
Référencé par ~SH_DatabaseManager()\&.
.PP
.nf
111 {
112 
113     /*close database
114     */
115     dbConnection\&.close();
116     return (!dbConnection\&.isOpen());
117 }
.fi
.SS "SH_DatabaseManager::divideQVariantMap (QVariantMapvalues, QString &fields, QString &vals)\fC [private]\fP"

.PP
\fBParamètres:\fP
.RS 4
\fIvalues\fP 
.br
\fIou]\fP fields 
.br
\fIou]\fP vals 
.RE
.PP

.PP
Définition à la ligne 241 du fichier SH_DatabaseManager\&.cpp\&.
.PP
Référencé par execInsertReturningQuery(), et execReplaceQuery()\&.
.PP
.nf
241                                                                                              {
242     for(auto field : values\&.keys())
243     {
244         fields += field+",";
245         QVariant val = values\&.value(field);
246         bool ok;
247         int intVal = val\&.toInt(&ok);
248         if(ok) {
249             vals += QString::number(intVal)+",";
250         }
251         double dbVal = val\&.toDouble(&ok);
252         if(ok) {
253             vals += QString::number(dbVal)+",";
254         }
255 
256         /*bool boolVal = val\&.toBool();
257     if(boolVal) {
258     &vals += "'"+1+"'',";
259     }*/
260         QDate dateVal = val\&.toDate();
261         if(dateVal\&.isValid()) {
262             vals += "'"+dateVal\&.toString()+"'',";
263             /*FIXME adapt date format*/
264         }
265         QDateTime dateTimeVal = val\&.toDateTime();
266         if(dateTimeVal\&.isValid()) {
267             vals += "'"+dateTimeVal\&.toString()+"'',";
268             /*FIXME adapt datetime format*/
269         }
270         QString stringVal = val\&.toString();
271         vals += "'"+stringVal+"'',";
272     }
273     fields = fields\&.left(fields\&.lastIndexOf(',')-1);
274     vals = vals\&.left(vals\&.lastIndexOf(',')-1);
275 }
.fi
.SS "SH_DatabaseManager::execInsertReturningQuery (QStringtableName, QVariantMapvalues, QStringreturningField)"

.PP
\fBParamètres:\fP
.RS 4
\fIquery\fP 
.br
\fIreturningField\fP 
.RE
.PP
\fBRenvoie:\fP
.RS 4
QVariant 
.RE
.PP

.PP
Définition à la ligne 218 du fichier SH_DatabaseManager\&.cpp\&.
.PP
Références dbConnection, et divideQVariantMap()\&.
.PP
Référencé par SH_AdaptDatabaseState::insertUpdate()\&.
.PP
.nf
218                                                                                                                    {
219     QString fields;
220     QString vals;
221     divideQVariantMap(values, fields, vals);
222     QString query;
223     if(dbConnection\&.driverName() == "QIBASE") {
224         query = QString("UPDATE OR INSERT INTO %1(%2) VALUES(%3) MATCHING(ID) RETURNING %4")\&.arg(tableName)\&.arg(fields)\&.arg(vals)\&.arg(returningField);
225     }
226     QSqlQuery result = dbConnection\&.exec(query);
227     //SH_MessageManager::debugMessage(QString("query %1: valid ? %2 active ? %3")\&.arg(result\&.executedQuery())\&.arg(result\&.isValid())\&.arg(result\&.isActive()));
228     if(result\&.next()) {
229         QSqlRecord rec = result\&.record();
230         if(!rec\&.isEmpty() && result\&.isValid()) {
231             return rec\&.value(rec\&.indexOf(returningField));
232         }
233     }
234     return QVariant();
235 }
.fi
.SS "SH_DatabaseManager::execReplaceQuery (QStringtableName, QVariantMapvalues)"

.PP
\fBParamètres:\fP
.RS 4
\fIquery\fP 
.RE
.PP
\fBRenvoie:\fP
.RS 4
bool 
.RE
.PP

.PP
Définition à la ligne 201 du fichier SH_DatabaseManager\&.cpp\&.
.PP
Références dbConnection, et divideQVariantMap()\&.
.PP
Référencé par SH_Trainee::save(), et SH_User::save()\&.
.PP
.nf
201                                                                                {
202     QString fields;
203     QString vals;
204     divideQVariantMap(values, fields, vals);
205     QString query;
206     if(dbConnection\&.driverName() == "QIBASE") {
207         query = QString("UPDATE OR INSERT INTO %1(%2) VALUES(%3) MATCHING(ID)")\&.arg(tableName)\&.arg(fields)\&.arg(vals);
208     }
209     QSqlQuery result = dbConnection\&.exec(query);
210     //SH_MessageManager::debugMessage(QString("query %1: valid ? %2 active ? %3")\&.arg(result\&.executedQuery())\&.arg(result\&.isValid())\&.arg(result\&.isActive()));
211     return (result\&.numRowsAffected() > 0);
212 }
.fi
.SS "QSqlQuery SH_DatabaseManager::execSelectQuery (QStringtableName, QStringListfields = \fCQStringList('*')\fP, QStringcondition = \fC''\fP, QStringordering = \fC''\fP)"

.PP
Définition à la ligne 174 du fichier SH_DatabaseManager\&.cpp\&.
.PP
Références dbConnection, et SH_MessageManager::debugMessage()\&.
.PP
Référencé par dataCount(), SH_SqlDataModel::fetch(), SH_User::logIn(), SH_ServiceCharging::SH_ServiceCharging(), SH_ApplicationCore::todayBalance(), et SH_ApplicationCore::totalBalance()\&.
.PP
.nf
174                                                                                                                         {
175     if(fields\&.isEmpty()) {
176         fields\&.append("*");
177     }
178 
179     QString query;
180     if(dbConnection\&.driverName() == "QIBASE") {
181         query = QString("SELECT %1 FROM %2")\&.arg(fields\&.join(", "))\&.arg(tableName);
182         if(!condition\&.isEmpty()) {
183             query = QString("%1 WHERE %2")\&.arg(query)\&.arg(condition);
184         }
185         if(!ordering\&.isEmpty()) {
186             query = QString("%1 ORDER BY %2")\&.arg(query)\&.arg(ordering);
187         }
188     }
189     SH_MessageManager::debugMessage(query);
190     QSqlQuery result;
191     result\&.exec(query);
192     SH_MessageManager::debugMessage(QString("query %1: valid ? %2 active ? %3")\&.arg(result\&.executedQuery())\&.arg(result\&.isValid())\&.arg(result\&.isActive()));
193     return result;
194 }
.fi
.SS "SH_DatabaseManager::getDbConnection ()"

.PP
\fBRenvoie:\fP
.RS 4
QSqlDatabase 
.RE
.PP

.PP
Définition à la ligne 134 du fichier SH_DatabaseManager\&.cpp\&.
.PP
Références dbConnection\&.
.PP
.nf
135 {
136     return dbConnection;
137 }
.fi
.SS "SH_DatabaseManager::getInstance ()\fC [static]\fP"

.PP
\fBRenvoie:\fP
.RS 4
\fBSH_DatabaseManager\fP 
.RE
.PP

.PP
Définition à la ligne 13 du fichier SH_DatabaseManager\&.cpp\&.
.PP
Références _instance, et SH_DatabaseManager()\&.
.PP
Référencé par SH_SqlDataModel::fetch(), SH_AdaptDatabaseState::insertUpdate(), SH_User::logIn(), SH_Trainee::save(), SH_User::save(), SH_ServiceCharging::SH_ServiceCharging(), SH_ApplicationCore::todayBalance(), SH_ApplicationCore::totalBalance(), SH_User::traineeExists(), et SH_User::userExists()\&.
.PP
.nf
14 {
15     if (_instance == 0)
16     {
17         _instance = new SH_DatabaseManager;
18     }
19     return _instance;
20 }
.fi
.SS "SH_DatabaseManager::isConnected ()"

.PP
\fBRenvoie:\fP
.RS 4
bool 
.RE
.PP

.PP
Définition à la ligne 124 du fichier SH_DatabaseManager\&.cpp\&.
.PP
Références dbConnection\&.
.PP
.nf
125 {
126     return dbConnection\&.isOpen();
127 }
.fi
.SS "SH_DatabaseManager::tableExists (QStringtableName)"

.PP
\fBParamètres:\fP
.RS 4
\fItableName\fP 
.RE
.PP
\fBRenvoie:\fP
.RS 4
bool 
.RE
.PP

.PP
Définition à la ligne 143 du fichier SH_DatabaseManager\&.cpp\&.
.PP
Références dbConnection\&.
.PP
.nf
144 {
145     return dbConnection\&.tables(QSql::Views)\&.contains(tableName\&.toUpper(), Qt::CaseInsensitive) || dbConnection\&.tables(QSql::Tables)\&.contains(tableName\&.toUpper(), Qt::CaseInsensitive);
146 }
.fi
.SH "Documentation des données membres"
.PP 
.SS "\fBSH_DatabaseManager\fP * SH_DatabaseManager::_instance = 0\fC [static]\fP, \fC [private]\fP"

.PP
_instance 
.PP
Définition à la ligne 69 du fichier SH_DatabaseManager\&.h\&.
.PP
Référencé par getInstance()\&.
.SS "QSqlDatabase SH_DatabaseManager::dbConnection\fC [protected]\fP"

.PP
dbConnection 
.PP
Définition à la ligne 92 du fichier SH_DatabaseManager\&.h\&.
.PP
Référencé par dataCount(), dbConnect(), dbDisconnect(), execInsertReturningQuery(), execReplaceQuery(), execSelectQuery(), getDbConnection(), isConnected(), SH_DatabaseManager(), et tableExists()\&.

.SH "Auteur"
.PP 
Généré automatiquement par Doxygen pour PreCheck à partir du code source\&.
