.TH "SH_SqlDataModel" 3 "Mardi Juillet 2 2013" "Version 0.4" "PreCheck" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SH_SqlDataModel \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <SH_SqlDataModel\&.h>\fP
.PP
Est dérivée de \fBQAbstractListModel\fP\&.
.SS "Signaux"

.in +1c
.ti -1c
.RI "void \fBfieldsChanged\fP ()"
.br
.ti -1c
.RI "void \fBfilterChanged\fP ()"
.br
.ti -1c
.RI "void \fBlastErrorChanged\fP ()"
.br
.ti -1c
.RI "void \fBrolesChanged\fP ()"
.br
.ti -1c
.RI "void \fBtableChanged\fP ()"
.br
.in -1c
.SS "Fonctions membres publiques"

.in +1c
.ti -1c
.RI "\fBSH_SqlDataModel\fP (\fBQObject\fP *parent=0)"
.br
.ti -1c
.RI "QVariant \fBdata\fP (const QModelIndex &index, int role) const "
.br
.ti -1c
.RI "QVariantMap \fBdatas\fP () const "
.br
.ti -1c
.RI "bool \fBfetch\fP (QString \fBtableName\fP='', QString \fBfilter\fP='', QString sort='', QStringList fields=QStringList())"
.br
.ti -1c
.RI "\fBSH_SqlDataFields\fP * \fBfield\fP (int i) const "
.br
.ti -1c
.RI "int \fBfieldFromRole\fP (int role) const "
.br
.ti -1c
.RI "int \fBfieldsCount\fP () const "
.br
.ti -1c
.RI "const QStringList \fBfieldsList\fP () const "
.br
.ti -1c
.RI "const QString & \fBfilter\fP () const "
.br
.ti -1c
.RI "bool \fBisEmpty\fP () const "
.br
.ti -1c
.RI "const QString \fBlastError\fP ()"
.br
.ti -1c
.RI "const QString \fBquery\fP () const "
.br
.ti -1c
.RI "void \fBresetFieldsToAll\fP ()"
.br
.ti -1c
.RI "void \fBresetFilterCondition\fP ()"
.br
.ti -1c
.RI "int \fBroleForField\fP (int fieldIndex) const "
.br
.ti -1c
.RI "virtual QHash< int, QByteArray > \fBroleNames\fP () const "
.br
.RI "\fIThis function allows mapping of role identifiers to role property names in scripting languages\&. \fP"
.ti -1c
.RI "int \fBrowCount\fP (const QModelIndex &parent) const "
.br
.ti -1c
.RI "void \fBsetFields\fP (QStringList fieldList)"
.br
.ti -1c
.RI "void \fBsetFilterCondition\fP (const QString &\fBfilter\fP)"
.br
.ti -1c
.RI "bool \fBsetHeaderData\fP (int section, Qt::Orientation orientation, const QVariant &value, int role=Qt::EditRole)"
.br
.ti -1c
.RI "void \fBsetOrderBy\fP (QString sort)"
.br
.ti -1c
.RI "void \fBsetTable\fP (const QString &\fBtableName\fP)"
.br
.ti -1c
.RI "const QString & \fBtableName\fP () const "
.br
.in -1c
.SS "Fonctions membres protégées"

.in +1c
.ti -1c
.RI "void \fBapplyRoles\fP ()"
.br
.in -1c
.SS "Propriétés"

.in +1c
.ti -1c
.RI "QString \fBfilter\fP"
.br
.ti -1c
.RI "QString \fBlastError\fP"
.br
.ti -1c
.RI "QString \fBtable\fP"
.br
.in -1c
.SS "Attributs privés"

.in +1c
.ti -1c
.RI "QList< \fBSH_SqlDataFields\fP * > \fBmDataFields\fP"
.br
.RI "\fImDataFields \fP"
.ti -1c
.RI "QString \fBmFilter\fP"
.br
.RI "\fImFilter \fP"
.ti -1c
.RI "QList< QSqlRecord > \fBmRecords\fP"
.br
.RI "\fImRecords \fP"
.ti -1c
.RI "QHash< int, QByteArray > \fBmRoles\fP"
.br
.RI "\fImRoles \fP"
.ti -1c
.RI "QString \fBmSort\fP"
.br
.RI "\fImSort \fP"
.ti -1c
.RI "QSqlQuery \fBmSqlQuery\fP"
.br
.RI "\fImSqlQuery \fP"
.ti -1c
.RI "QString \fBmTable\fP"
.br
.RI "\fImTable \fP"
.in -1c
.SH "Description détaillée"
.PP 
Définition à la ligne 12 du fichier SH_SqlDataModel\&.h\&.
.SH "Documentation des constructeurs et destructeur"
.PP 
.SS "SH_SqlDataModel::SH_SqlDataModel (\fBQObject\fP *parent = \fC0\fP)\fC [explicit]\fP"

.PP
Définition à la ligne 14 du fichier SH_SqlDataModel\&.cpp\&.
.PP
.nf
14                                                 :
15     QAbstractListModel(parent)
16 {
17 }
.fi
.SH "Documentation des fonctions membres"
.PP 
.SS "SH_SqlDataModel::applyRoles ()\fC [protected]\fP"

.PP
Définition à la ligne 292 du fichier SH_SqlDataModel\&.cpp\&.
.PP
Références mDataFields, mRoles, roleForField(), et rolesChanged()\&.
.PP
Référencé par fetch(), resetFieldsToAll(), et setFields()\&.
.PP
.nf
293 {
294     this->mRoles\&.clear();
295     int nbFields = this->mDataFields\&.count();
296     for (int i = 0; i < nbFields; i++)
297     {
298         this->mRoles\&.insert(this->roleForField(i), this->mDataFields\&.at(i)->role());
299     }
300     emit rolesChanged();
301 }
.fi
.SS "SH_SqlDataModel::data (const QModelIndex &index, introle) const"

.PP
\fBParamètres:\fP
.RS 4
\fIindex\fP 
.br
\fIrole\fP 
.RE
.PP
\fBRenvoie:\fP
.RS 4
QVariant 
.RE
.PP

.PP
Définition à la ligne 31 du fichier SH_SqlDataModel\&.cpp\&.
.PP
Références SH_MessageManager::debugMessage(), SH_MessageManager::errorMessage(), fieldFromRole(), mDataFields, mRecords, et mRoles\&.
.PP
Référencé par SH_ExtendedProxyModel::data()\&.
.PP
.nf
32 {
33     if (this->mRecords\&.count() > 0)
34     {
35         int row = index\&.row();
36         int column = this->fieldFromRole(role);
37         int nbCols = this->mRoles\&.count();
38         if(column >= 0 && column < nbCols) {
39             SH_MessageManager::debugMessage(QString("row : %1, column : %2, field: %3 (%4), value : %5\n")\&.arg(index\&.row())\&.arg(index\&.column())\&.arg(column)\&.arg(QString(this->mDataFields\&.at(column)->role()))\&.arg(this->mRecords\&.at(row)\&.value(column)\&.toString()));
40             return this->mRecords\&.at(row)\&.value(column);
41         } else{
42             SH_MessageManager::errorMessage(QString("rien à retourner pour %1x%2x%3 (%4>=%5)")\&.arg(index\&.row())\&.arg(index\&.column())\&.arg(role)\&.arg(column)\&.arg(nbCols));
43         }
44     }
45     SH_MessageManager::errorMessage("modèle vide");
46     return QVariant();
47 }
.fi
.SS "SH_SqlDataModel::datas () const"

.PP
\fBParamètres:\fP
.RS 4
\fIindex\fP 
.br
\fIrole\fP 
.RE
.PP
\fBRenvoie:\fP
.RS 4
QVariant 
.RE
.PP

.PP
Définition à la ligne 53 du fichier SH_SqlDataModel\&.cpp\&.
.PP
Références SH_MessageManager::debugMessage(), mRecords, et mRoles\&.
.PP
Référencé par SH_DatabaseContentQuestionState::SH_DatabaseContentQuestionState()\&.
.PP
.nf
54 {
55     SH_MessageManager::debugMessage("datas");
56     QVariantMap result;
57     if (this->mRecords\&.count() > 0)
58     {
59         for(int column = 0; column < this->mRoles\&.count(); column++) {
60             for(int row = 0; row < this->mRecords\&.count();row++) {
61                 SH_MessageManager::debugMessage( "data inserted");
62                 result\&.insertMulti(this->mRoles\&.value(column),this->mRecords\&.at(row)\&.value(column));
63             }
64         }
65     }
66     return result;
67 }
.fi
.SS "SH_SqlDataModel::fetch (QStringtableName = \fC''\fP, QStringfilter = \fC''\fP, QStringsort = \fC''\fP, QStringListfields = \fCQStringList()\fP)"

.PP
\fBParamètres:\fP
.RS 4
\fItableName\fP 
.br
\fIfilter\fP 
.br
\fIsort\fP 
.br
\fIfields\fP 
.RE
.PP
\fBRenvoie:\fP
.RS 4
bool 
.RE
.PP

.PP
Définition à la ligne 159 du fichier SH_SqlDataModel\&.cpp\&.
.PP
Références applyRoles(), SH_MessageManager::debugMessage(), SH_MessageManager::errorMessage(), SH_DatabaseManager::execSelectQuery(), field(), fieldsChanged(), fieldsList(), SH_DatabaseManager::getInstance(), isEmpty(), lastError(), mDataFields, mFilter, mRecords, mSort, mSqlQuery, mTable, setFields(), setFilterCondition(), SH_SqlDataFields::setName(), setOrderBy(), et setTable()\&.
.PP
Référencé par SH_ExtendedProxyModel::fetch(), et SH_DatabaseContentQuestionState::SH_DatabaseContentQuestionState()\&.
.PP
.nf
160 {
161     if(!mTable\&.isEmpty() || !tableName\&.isEmpty()) {
162         SH_MessageManager::debugMessage("Bienvenue dans fetch");
163         SH_MessageManager::debugMessage(mTable + " " + this->fieldsList()\&.join(", ") + " " +mFilter + " " + mSort);
164         this->setFields(fieldsList);
165         this->setTable(tableName);
166         this->setFilterCondition(filter);
167         this->setOrderBy(sort);
168         SH_MessageManager::debugMessage(mTable + " " + this->fieldsList()\&.join(", ") + " " +filter + " " + sort);
169         try
170         {
171             beginResetModel();
172             mRecords\&.clear();
173             endResetModel();
174             SH_MessageManager::debugMessage(mTable + " " + this->fieldsList()\&.join(", ") + " " +mFilter + " " + mSort);
175             mSqlQuery = SH_DatabaseManager::getInstance()->execSelectQuery(mTable, this->fieldsList(), mFilter, mSort);
176             bool next = mSqlQuery\&.next();
177             //SH_MessageManager::infoMessage(mSqlQuery\&.executedQuery());
178             /*if(next) {
179                 SH_MessageManager::debugMessage("next ok");
180             }*/
181             while (next)
182             {
183                 QSqlRecord record = mSqlQuery\&.record();
184 
185                 SH_MessageManager::debugMessage("Nouvelle ligne récupérée");
186                 SH_MessageManager::debugMessage(QString("%1 champs")\&.arg(record\&.count()));
187                 if (mSqlQuery\&.isValid() && (!record\&.isEmpty()) && (record\&.count() > 0))
188                 {
189                     beginInsertRows(QModelIndex(), 0, 0);
190                     mRecords\&.append(record);
191 //#ifdef DEBUG
192                     int nbFields = record\&.count();
193                     for (int i = 0; i < nbFields; i++)
194                     {
195                         SH_MessageManager::debugMessage(QString("%1 : %2")\&.arg(record\&.fieldName(i))\&.arg(record\&.value(i)\&.toString()));
196                     }
197 //#endif
198                     if (mDataFields\&.empty())
199                     {
200                         int nbFields = record\&.count();
201                         for (int i = 0; i < nbFields; i++)
202                         {
203                             SH_SqlDataFields *field = new SH_SqlDataFields();
204                             field->setName(record\&.fieldName(i));
205                             //SH_MessageManager::debugMessage(QString("nouveau champ (le n°%1): %2")\&.arg(i)\&.arg(field->name()));
206                             mDataFields\&.append(field);
207                         }
208                         this->applyRoles();
209                         emit fieldsChanged();
210                     }
211                     endInsertRows();
212                 }
213                 next = mSqlQuery\&.next();
214             }
215         }
216         catch (const std::exception &e)
217         {
218             SH_MessageManager::errorMessage(e\&.what(), "exception");
219             if (this->lastError()\&.isEmpty())
220             {
221                 SH_MessageManager::errorMessage(this->lastError(), "erreur SQL");
222             }
223         }
224         if (this->lastError()\&.isEmpty())
225         {
226             SH_MessageManager::errorMessage(this->lastError(), "erreur SQL");
227         }
228     }
229     return (!this->isEmpty());
230 }
.fi
.SS "SH_SqlDataModel::field (inti) const"

.PP
\fBParamètres:\fP
.RS 4
\fIi\fP 
.RE
.PP
\fBRenvoie:\fP
.RS 4
SqlDataFields 
.RE
.PP

.PP
Définition à la ligne 235 du fichier SH_SqlDataModel\&.cpp\&.
.PP
Références fieldsCount(), et mDataFields\&.
.PP
Référencé par fetch(), SH_ExtendedProxyModel::field(), SH_BillingsTableModel::fillModel(), SH_BookingsTableModel::fillModel(), setFields(), SH_ExtendedProxyModel::setSortKeyColumn(), et SH_ExtendedProxyModel::sort()\&.
.PP
.nf
236 {
237     i = qMin(i, this->fieldsCount()-1);
238     i = qMax(i, 0);
239     return this->mDataFields\&.at(i);
240 }
.fi
.SS "SH_SqlDataModel::fieldFromRole (introle) const\fC [inline]\fP"

.PP
\fBParamètres:\fP
.RS 4
\fIrole\fP 
.RE
.PP
\fBRenvoie:\fP
.RS 4
int 
.RE
.PP

.PP
Définition à la ligne 78 du fichier SH_SqlDataModel\&.h\&.
.PP
Référencé par data()\&.
.PP
.nf
78 { return role - Qt::UserRole; }
.fi
.SS "SH_SqlDataModel::fieldsChanged ()\fC [signal]\fP"

.PP
Référencé par fetch(), resetFieldsToAll(), et setFields()\&.
.SS "SH_SqlDataModel::fieldsCount () const"

.PP
\fBRenvoie:\fP
.RS 4
int 
.RE
.PP

.PP
Définition à la ligne 306 du fichier SH_SqlDataModel\&.cpp\&.
.PP
Références mDataFields\&.
.PP
Référencé par field(), et SH_ExtendedProxyModel::fieldsCount()\&.
.PP
.nf
307 {
308     return mDataFields\&.count();
309 }
.fi
.SS "SH_SqlDataModel::fieldsList () const"

.PP
\fBRenvoie:\fP
.RS 4
const QString 
.RE
.PP

.PP
Définition à la ligne 110 du fichier SH_SqlDataModel\&.cpp\&.
.PP
Références mDataFields\&.
.PP
Référencé par SH_ExtendedProxyModel::data(), SH_ExtendedProxyModel::fetch(), fetch(), SH_ExtendedProxyModel::fields(), SH_BillingsTableModel::fillModel(), SH_VATTableModel::fillModel(), SH_RoomsTableModel::fillModel(), SH_TraineesTableModel::fillModel(), SH_ServicesTableModel::fillModel(), et SH_UsersTableModel::fillModel()\&.
.PP
.nf
111 {
112     QStringList fields;
113     if(!this->mDataFields\&.isEmpty()) {
114         int c = mDataFields\&.count();
115         for (int i = 0; i < c; i++)
116         {
117             fields \&.append(this->mDataFields\&.at(i)->name());
118         }
119     }
120     return fields;
121 }
.fi
.SS "const QString& SH_SqlDataModel::filter () const"

.PP
Référencé par setFilterCondition()\&.
.SS "SH_SqlDataModel::filterChanged ()\fC [signal]\fP"

.PP
Référencé par resetFilterCondition(), et setFilterCondition()\&.
.SS "SH_SqlDataModel::isEmpty () const"

.PP
\fBRenvoie:\fP
.RS 4
bool 
.RE
.PP

.PP
Définition à la ligne 322 du fichier SH_SqlDataModel\&.cpp\&.
.PP
Références mRecords\&.
.PP
Référencé par fetch(), et SH_ExtendedProxyModel::isEmpty()\&.
.PP
.nf
323 {
324     return mRecords\&.empty();
325 }
.fi
.SS "const QString SH_SqlDataModel::lastError ()"

.PP
Référencé par fetch()\&.
.SS "SH_SqlDataModel::lastErrorChanged ()\fC [signal]\fP"

.SS "SH_SqlDataModel::query () const"

.PP
\fBRenvoie:\fP
.RS 4
const QString 
.RE
.PP

.PP
Définition à la ligne 86 du fichier SH_SqlDataModel\&.cpp\&.
.PP
Références mSqlQuery\&.
.PP
.nf
87 {
88     return mSqlQuery\&.lastQuery();
89 }
.fi
.SS "SH_SqlDataModel::resetFieldsToAll ()"

.PP
Définition à la ligne 265 du fichier SH_SqlDataModel\&.cpp\&.
.PP
Références applyRoles(), fieldsChanged(), et mDataFields\&.
.PP
.nf
266 {
267     mDataFields\&.clear();
268     this->applyRoles();
269     emit fieldsChanged();
270 }
.fi
.SS "SH_SqlDataModel::resetFilterCondition ()"

.PP
Définition à la ligne 150 du fichier SH_SqlDataModel\&.cpp\&.
.PP
Références filterChanged(), et mFilter\&.
.PP
.nf
151 {
152     mFilter = "";
153     emit filterChanged();
154 }
.fi
.SS "SH_SqlDataModel::roleForField (intfieldIndex) const\fC [inline]\fP"

.PP
\fBParamètres:\fP
.RS 4
\fIfieldIndex\fP 
.RE
.PP
\fBRenvoie:\fP
.RS 4
int 
.RE
.PP

.PP
Définition à la ligne 70 du fichier SH_SqlDataModel\&.h\&.
.PP
Référencé par applyRoles(), SH_ExtendedProxyModel::data(), et SH_ExtendedProxyModel::setSortKeyColumn()\&.
.PP
.nf
70 { return Qt::UserRole + fieldIndex;}
.fi
.SS "SH_SqlDataModel::roleNames () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
This function allows mapping of role identifiers to role property names in scripting languages\&. !
.PP
\fBRenvoie:\fP
.RS 4
QHash<int, QByteArray> 
.RE
.PP

.PP
Définition à la ligne 175 du fichier SH_SqlDataModel\&.h\&.
.PP
Références mRoles\&.
.PP
Référencé par SH_ExtendedProxyModel::roleNames()\&.
.PP
.nf
175 { return this->mRoles; }
.fi
.SS "SH_SqlDataModel::rolesChanged ()\fC [signal]\fP"

.PP
Référencé par applyRoles()\&.
.SS "SH_SqlDataModel::rowCount (const QModelIndex &parent) const"

.PP
\fBParamètres:\fP
.RS 4
\fIparent\fP 
.RE
.PP
\fBRenvoie:\fP
.RS 4
int 
.RE
.PP

.PP
Définition à la ligne 22 du fichier SH_SqlDataModel\&.cpp\&.
.PP
Références mRecords\&.
.PP
.nf
23 {
24     Q_UNUSED(parent);
25     return mRecords\&.count();
26 }
.fi
.SS "SH_SqlDataModel::setFields (QStringListfieldList)"

.PP
\fBParamètres:\fP
.RS 4
\fIfieldList\fP 
.RE
.PP

.PP
Définition à la ligne 245 du fichier SH_SqlDataModel\&.cpp\&.
.PP
Références applyRoles(), field(), fieldsChanged(), mDataFields, et SH_SqlDataFields::setName()\&.
.PP
Référencé par fetch()\&.
.PP
.nf
246 {
247     fields\&.removeDuplicates();
248     int nbFields = fields\&.count();
249     if (nbFields > 0)
250     {
251         for (int i = 0; i < nbFields; i++)
252         {
253             SH_SqlDataFields *field = new SH_SqlDataFields();
254             field->setName(fields\&.at(i));
255             mDataFields\&.append(field);
256         }
257         this->applyRoles();
258         emit fieldsChanged();
259     }
260 }
.fi
.SS "SH_SqlDataModel::setFilterCondition (const QString &filter)"

.PP
\fBParamètres:\fP
.RS 4
\fIfilter\fP 
.RE
.PP

.PP
Définition à la ligne 138 du fichier SH_SqlDataModel\&.cpp\&.
.PP
Références filter(), filterChanged(), et mFilter\&.
.PP
Référencé par fetch(), SH_BookingsTableModel::SH_BookingsTableModel(), et SH_VATTableModel::SH_VATTableModel()\&.
.PP
.nf
139 {
140     if (mFilter != filter && filter != "")
141     {
142         mFilter = filter;
143         emit filterChanged();
144     }
145 }
.fi
.SS "SH_SqlDataModel::setHeaderData (intsection, Qt::Orientationorientation, const QVariant &value, introle = \fCQt::EditRole\fP)"

.PP
\fBParamètres:\fP
.RS 4
\fIsection\fP 
.br
\fIorientation\fP 
.br
\fIvalue\fP 
.br
\fIrole\fP 
.RE
.PP
\fBRenvoie:\fP
.RS 4
bool 
.RE
.PP

.PP
Définition à la ligne 72 du fichier SH_SqlDataModel\&.cpp\&.
.PP
Références mDataFields\&.
.PP
Référencé par SH_BillingsTableModel::fillModel(), SH_BookingsTableModel::fillModel(), SH_VATTableModel::fillModel(), SH_TraineesTableModel::fillModel(), SH_RoomsTableModel::fillModel(), et SH_UsersTableModel::fillModel()\&.
.PP
.nf
73 {
74     Q_UNUSED(role);
75     if (orientation == Qt::Horizontal)
76     {
77         this->mDataFields\&.at(section)->setText(value\&.toString());
78         return (this->mDataFields\&.at(section)->text() == value\&.toString());
79     }
80     return false;
81 }
.fi
.SS "SH_SqlDataModel::setOrderBy (QStringsort)"

.PP
\fBParamètres:\fP
.RS 4
\fIsort\fP 
.RE
.PP

.PP
Définition à la ligne 314 du fichier SH_SqlDataModel\&.cpp\&.
.PP
Références mSort\&.
.PP
Référencé par fetch(), SH_RoomsTableModel::SH_RoomsTableModel(), et SH_VATTableModel::SH_VATTableModel()\&.
.PP
.nf
315 {
316     this->mSort = sort;
317 }
.fi
.SS "SH_SqlDataModel::setTable (const QString &tableName)"

.PP
\fBParamètres:\fP
.RS 4
\fItableName\fP 
.RE
.PP

.PP
Définition à la ligne 126 du fichier SH_SqlDataModel\&.cpp\&.
.PP
Références mTable, et tableChanged()\&.
.PP
Référencé par fetch(), SH_BillingsTableModel::SH_BillingsTableModel(), SH_BillsTableModel::SH_BillsTableModel(), SH_BookingsTableModel::SH_BookingsTableModel(), SH_ClientsTableModel::SH_ClientsTableModel(), SH_GroupsTableModel::SH_GroupsTableModel(), SH_RoomsTableModel::SH_RoomsTableModel(), SH_ServicesTableModel::SH_ServicesTableModel(), SH_TraineesTableModel::SH_TraineesTableModel(), SH_UsersTableModel::SH_UsersTableModel(), et SH_VATTableModel::SH_VATTableModel()\&.
.PP
.nf
127 {
128     if (mTable\&.toUpper() != tableName\&.toUpper() && tableName != "")
129     {
130         mTable = tableName\&.toUpper();
131         emit tableChanged();
132     }
133 }
.fi
.SS "SH_SqlDataModel::tableChanged ()\fC [signal]\fP"

.PP
Référencé par setTable()\&.
.SS "SH_SqlDataModel::tableName () const"

.PP
\fBRenvoie:\fP
.RS 4
const QString 
.RE
.PP

.PP
Définition à la ligne 94 du fichier SH_SqlDataModel\&.cpp\&.
.PP
Références mTable\&.
.PP
Référencé par SH_ExtendedProxyModel::tableName()\&.
.PP
.nf
95 {
96     return mTable;
97 }
.fi
.SH "Documentation des données membres"
.PP 
.SS "QList<\fBSH_SqlDataFields\fP *> SH_SqlDataModel::mDataFields\fC [private]\fP"

.PP
mDataFields 
.PP
Définition à la ligne 256 du fichier SH_SqlDataModel\&.h\&.
.PP
Référencé par applyRoles(), data(), fetch(), field(), fieldsCount(), fieldsList(), resetFieldsToAll(), setFields(), et setHeaderData()\&.
.SS "QString SH_SqlDataModel::mFilter\fC [private]\fP"

.PP
mFilter 
.PP
Définition à la ligne 246 du fichier SH_SqlDataModel\&.h\&.
.PP
Référencé par fetch(), resetFilterCondition(), et setFilterCondition()\&.
.SS "QList<QSqlRecord> SH_SqlDataModel::mRecords\fC [private]\fP"

.PP
mRecords 
.PP
Définition à la ligne 271 du fichier SH_SqlDataModel\&.h\&.
.PP
Référencé par data(), datas(), fetch(), isEmpty(), et rowCount()\&.
.SS "QHash<int, QByteArray> SH_SqlDataModel::mRoles\fC [private]\fP"

.PP
mRoles 
.PP
Définition à la ligne 261 du fichier SH_SqlDataModel\&.h\&.
.PP
Référencé par applyRoles(), data(), datas(), et roleNames()\&.
.SS "QString SH_SqlDataModel::mSort\fC [private]\fP"

.PP
mSort 
.PP
Définition à la ligne 251 du fichier SH_SqlDataModel\&.h\&.
.PP
Référencé par fetch(), et setOrderBy()\&.
.SS "QSqlQuery SH_SqlDataModel::mSqlQuery\fC [private]\fP"

.PP
mSqlQuery 
.PP
Définition à la ligne 266 du fichier SH_SqlDataModel\&.h\&.
.PP
Référencé par fetch(), et query()\&.
.SS "QString SH_SqlDataModel::mTable\fC [private]\fP"

.PP
mTable 
.PP
Définition à la ligne 241 du fichier SH_SqlDataModel\&.h\&.
.PP
Référencé par fetch(), setTable(), et tableName()\&.
.SH "Documentation des propriétés"
.PP 
.SS "SH_SqlDataModel::filter\fC [read]\fP, \fC [write]\fP"

.PP
\fBRenvoie:\fP
.RS 4
const QString 
.RE
.PP

.PP
Définition à la ligne 16 du fichier SH_SqlDataModel\&.h\&.
.SS "SH_SqlDataModel::lastError\fC [read]\fP"

.PP
\fBRenvoie:\fP
.RS 4
const QString 
.RE
.PP

.PP
Définition à la ligne 17 du fichier SH_SqlDataModel\&.h\&.
.PP
Référencé par SH_ExtendedProxyModel::lastError()\&.
.SS "QString SH_SqlDataModel::table\fC [read]\fP, \fC [write]\fP"

.PP
Définition à la ligne 15 du fichier SH_SqlDataModel\&.h\&.

.SH "Auteur"
.PP 
Généré automatiquement par Doxygen pour PreCheck à partir du code source\&.
