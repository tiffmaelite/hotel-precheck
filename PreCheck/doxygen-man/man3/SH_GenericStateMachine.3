.TH "SH_GenericStateMachine" 3 "Mardi Juillet 2 2013" "Version 0.4" "PreCheck" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SH_GenericStateMachine \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <SH_GenericDebugableStateMachine\&.h>\fP
.PP
Est dérivée de \fBQStateMachine\fP, et \fBSH_NamedObject\fP\&.
.PP
Dérivée par \fBSH_InOutStateMachine\fP\&.
.SS "Signaux"

.in +1c
.ti -1c
.RI "void \fBgoNext\fP ()"
.br
.ti -1c
.RI "void \fBnext\fP ()"
.br
.in -1c
.SS "Fonctions membres publiques"

.in +1c
.ti -1c
.RI "\fBSH_GenericStateMachine\fP (QString \fBname\fP='', \fBQObject\fP *parent=0)"
.br
.ti -1c
.RI "virtual void \fBaddState\fP (QAbstractState *state)"
.br
.ti -1c
.RI "virtual void \fBsetStatesNextTransition\fP (QAbstractState *previousState, QAbstractState *nextState)"
.br
.ti -1c
.RI "QString \fBtoString\fP ()"
.br
.in -1c
.SS "Connecteurs protégés"

.in +1c
.ti -1c
.RI "void \fBemitGoNext\fP ()"
.br
.in -1c
.SS "Fonctions membres protégées"

.in +1c
.ti -1c
.RI "void \fBonEntry\fP (QEvent *event)"
.br
.ti -1c
.RI "void \fBonExit\fP (QEvent *event)"
.br
.in -1c
.SS "Fonctions membres privées"

.in +1c
.ti -1c
.RI "virtual QString \fBname\fP () const "
.br
.ti -1c
.RI "QString \fBptraddress\fP () const "
.br
.ti -1c
.RI "virtual void \fBsetName\fP (const QString &\fBname\fP)"
.br
.in -1c
.SS "Attributs privés"

.in +1c
.ti -1c
.RI "QAbstractState * \fBm_currentState\fP"
.br
.ti -1c
.RI "\fBQState\fP * \fBm_errorState\fP"
.br
.in -1c
.SH "Description détaillée"
.PP 
Définition à la ligne 6 du fichier SH_GenericDebugableStateMachine\&.h\&.
.SH "Documentation des constructeurs et destructeur"
.PP 
.SS "SH_GenericStateMachine::SH_GenericStateMachine (QStringname = \fC''\fP, \fBQObject\fP *parent = \fC0\fP)"

.PP
\fBParamètres:\fP
.RS 4
\fIname\fP 
.br
\fIparent\fP 
.RE
.PP

.PP
Définition à la ligne 15 du fichier SH_GenericDebugableStateMachine\&.cpp\&.
.PP
Références addState(), emitGoNext(), SH_MessageManager::errorMessage(), goNext(), m_errorState, et toString()\&.
.PP
.nf
15                                                                             :
16     QStateMachine(parent), SH_NamedObject(name), m_currentState(NULL)
17 {
18     this->setObjectName(name);
19     connect(this, &SH_GenericStateMachine::goNext, this, &SH_GenericStateMachine::emitGoNext);
20     m_errorState = new SH_GenericState("error state");
21     this->addState(m_errorState);
22     this->setErrorState(m_errorState);
23     /*connect(this, &SH_GenericStateMachine::entered, [=]() {*/
24     connect(m_errorState, &QState::entered, [=]() {
25         SH_MessageManager::errorMessage("Error in machine " +this->toString() + ": " + this->errorString());
26     });
27     connect(m_errorState, &QState::exited, [=]() {
28         m_errorState->disconnect(this);
29     });
30     /*});*/
31 }
.fi
.SH "Documentation des fonctions membres"
.PP 
.SS "void SH_GenericStateMachine::addState (QAbstractState *state)\fC [virtual]\fP"

.PP
Définition à la ligne 59 du fichier SH_GenericDebugableStateMachine\&.cpp\&.
.PP
Références m_currentState\&.
.PP
Référencé par SH_InOutStateMachine::addState(), et SH_GenericStateMachine()\&.
.PP
.nf
59                                                            {
60     /*connect(this, &SH_GenericStateMachine::entered, [=]() {*/
61     connect(state, &QAbstractState::entered, [=]() {
62         this->m_currentState = state;
63     });
64     connect(state, &QAbstractState::exited, [=]() {
65         this->m_currentState = NULL;
66         state->disconnect(this);
67     });
68     /*});*/
69     QStateMachine::addState(state);
70 }
.fi
.SS "void SH_GenericStateMachine::emitGoNext ()\fC [protected]\fP, \fC [slot]\fP"

.PP
Définition à la ligne 52 du fichier SH_GenericDebugableStateMachine\&.cpp\&.
.PP
Références next()\&.
.PP
Référencé par SH_GenericStateMachine()\&.
.PP
.nf
53 {
54     if(isRunning()) {
55         emit next();
56     }
57 }
.fi
.SS "SH_GenericStateMachine::goNext ()\fC [signal]\fP"

.PP
Référencé par SH_AddressCreationStateMachine::SH_AddressCreationStateMachine(), et SH_GenericStateMachine()\&.
.SS "SH_NamedObject::name () const\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBRenvoie:\fP
.RS 4
QString 
.RE
.PP

.PP
Définition à la ligne 26 du fichier SH_NamedObject\&.cpp\&.
.PP
Références SH_NamedObject::m_name\&.
.PP
Référencé par onEntry(), SH_GenericState::onEntry(), onExit(), SH_GenericState::onExit(), SH_NamedObject::setName(), et SH_ServiceCharging::SH_ServiceCharging()\&.
.PP
.nf
27 {
28     return m_name;
29 }
.fi
.SS "SH_GenericStateMachine::next ()\fC [signal]\fP"

.PP
Référencé par SH_InOutStateMachine::addChildrenReplaceTransition(), emitGoNext(), setStatesNextTransition(), et SH_LoopingInOutStateMachine::setStatesNextTransition()\&.
.SS "SH_GenericStateMachine::onEntry (QEvent *event)\fC [protected]\fP"

.PP
\fBParamètres:\fP
.RS 4
\fIevent\fP 
.RE
.PP

.PP
Définition à la ligne 77 du fichier SH_GenericDebugableStateMachine\&.cpp\&.
.PP
Références SH_MessageManager::debugMessage(), et SH_NamedObject::name()\&.
.PP
.nf
78 {
79     Q_UNUSED(event);
80     SH_MessageManager::debugMessage(this->name() + " entered");
81 }
.fi
.SS "SH_GenericStateMachine::onExit (QEvent *event)\fC [protected]\fP"

.PP
\fBParamètres:\fP
.RS 4
\fIevent\fP 
.RE
.PP

.PP
Définition à la ligne 87 du fichier SH_GenericDebugableStateMachine\&.cpp\&.
.PP
Références SH_MessageManager::debugMessage(), et SH_NamedObject::name()\&.
.PP
.nf
88 {
89     Q_UNUSED(event);
90     SH_MessageManager::debugMessage(this->name() + " exited");
91 }
.fi
.SS "SH_NamedObject::ptraddress () const\fC [inherited]\fP"

.PP
\fBRenvoie:\fP
.RS 4
QString 
.RE
.PP

.PP
Définition à la ligne 42 du fichier SH_NamedObject\&.cpp\&.
.PP
Références SH_NamedObject::m_ptraddress\&.
.PP
.nf
43 {
44     return m_ptraddress;
45 }
.fi
.SS "SH_NamedObject::setName (const QString &name)\fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBParamètres:\fP
.RS 4
\fIname\fP 
.RE
.PP

.PP
Définition à la ligne 34 du fichier SH_NamedObject\&.cpp\&.
.PP
Références SH_NamedObject::m_name, et SH_NamedObject::name()\&.
.PP
.nf
35 {
36     m_name = name;
37 }
.fi
.SS "void SH_GenericStateMachine::setStatesNextTransition (QAbstractState *previousState, QAbstractState *nextState)\fC [virtual]\fP"

.PP
Réimplémentée dans \fBSH_LoopingInOutStateMachine\fP\&.
.PP
Définition à la ligne 96 du fichier SH_GenericDebugableStateMachine\&.cpp\&.
.PP
Références next()\&.
.PP
Référencé par SH_LoopingInOutStateMachine::setStatesNextTransition(), et SH_InOutStateMachine::setStatesNextTransition()\&.
.PP
.nf
97 {
98     QState* pState = qobject_cast<QState*>(previousState);
99     if(pState) {
100         QList<QAbstractTransition*> transitions = pState->transitions();
101         foreach(QAbstractTransition* tran, transitions) {
102             QSignalTransition* signalTransition = qobject_cast<QSignalTransition*>(tran);
103             if(signalTransition) {
104                 //SH_MessageManager::infoMessage(QString(signalTransition->signal()));
105                 if(signalTransition->signal()\&.contains("next()")) {
106                     pState->removeTransition(signalTransition);
107                 }
108             }
109         }
110 
111         SH_GenericStateMachine* fsmPreviousState = qobject_cast<SH_GenericStateMachine*>(previousState);
112         SH_GenericState* genPreviousState = qobject_cast<SH_GenericState*>(previousState);
113         if(genPreviousState) {
114             /*connect(this, &SH_GenericStateMachine::entered, [=]() {
115                 connect(genPreviousState, &SH_GenericState::entered, [=]() {*/
116             //SH_MessageManager::debugMessage(QString("next transition between %1 and %2")\&.arg(genPreviousState->toString())\&.arg(nextState->objectName()));
117             genPreviousState->addTransition(genPreviousState, SIGNAL(next()), nextState);
118             /*});*/
119 
120             connect(genPreviousState, &SH_GenericState::exited, [=]() {
121                 genPreviousState->disconnect(this);
122             });
123             /*});*/
124         }
125         if(fsmPreviousState) {
126             /*connect(this, &SH_GenericStateMachine::entered, [=]() {
127                 connect(fsmPreviousState, &SH_GenericStateMachine::entered, [=]() {*/
128             //SH_MessageManager::debugMessage(QString("next transition between %1 and %2")\&.arg(fsmPreviousState->toString())\&.arg(nextState->objectName()));
129             fsmPreviousState->addTransition(fsmPreviousState, SIGNAL(next()), nextState);
130             /*});*/
131             connect(fsmPreviousState, &SH_GenericStateMachine::exited, [=]() {
132                 fsmPreviousState->disconnect(this);
133             });
134             /*});*/
135         }
136     }
137 }
.fi
.SS "SH_GenericStateMachine::toString ()\fC [virtual]\fP"

.PP
\fBRenvoie:\fP
.RS 4
QString 
.RE
.PP

.PP
Réimplémentée à partir de \fBSH_NamedObject\fP\&.
.PP
Définition à la ligne 37 du fichier SH_GenericDebugableStateMachine\&.cpp\&.
.PP
Références SH_NamedObject::toString(), et SH_GenericState::toString()\&.
.PP
Référencé par SH_LoopingInOutStateMachine::setStatesNextTransition(), SH_InOutStateMachine::setStatesNextTransition(), SH_BillingCreationStateMachine::SH_BillingCreationStateMachine(), et SH_GenericStateMachine()\&.
.PP
.nf
38 {
39     QObject* parent = this->parent();
40     SH_GenericState* par = qobject_cast<SH_GenericState *>(parent);
41     if(par) {
42         return SH_NamedObject::toString()+ " [descending from "+par->toString()+"] ";
43     } else {
44         return SH_NamedObject::toString();
45     }
46 }
.fi
.SH "Documentation des données membres"
.PP 
.SS "QAbstractState* SH_GenericStateMachine::m_currentState\fC [private]\fP"

.PP
Définition à la ligne 71 du fichier SH_GenericDebugableStateMachine\&.h\&.
.PP
Référencé par addState()\&.
.SS "SH_GenericStateMachine::m_errorState\fC [private]\fP"

.PP
Définition à la ligne 70 du fichier SH_GenericDebugableStateMachine\&.h\&.
.PP
Référencé par SH_GenericStateMachine()\&.

.SH "Auteur"
.PP 
Généré automatiquement par Doxygen pour PreCheck à partir du code source\&.
