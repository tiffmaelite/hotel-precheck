.TH "/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/PreCheck/main.cpp" 3 "Lundi Juin 24 2013" "Version 0.3" "PreCheck" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/tiff/Stage-IUT/app/simplhotel/hotel-precheck/src/PreCheck/main.cpp \- 
.SH SYNOPSIS
.br
.PP
\fC#include <QtWidgets/QApplication>\fP
.br
\fC#include <QtQml>\fP
.br
\fC#include <QtQuick>\fP
.br
\fC#include <QProgressDialog>\fP
.br
\fC#include 'SH_MessageManager\&.h'\fP
.br
\fC#include 'SH_ApplicationCore\&.h'\fP
.br
\fC#include 'models/SH_ExtendedSqlProxyModel\&.h'\fP
.br
\fC#include 'models/SH_RoomsTableModel\&.h'\fP
.br
\fC#include 'models/SH_SqlDataField\&.h'\fP
.br
\fC#include 'models/SH_BillingsTableModel\&.h'\fP
.br
\fC#include 'models/SH_BillsTableModel\&.h'\fP
.br
\fC#include 'models/SH_BookingsTableModel\&.h'\fP
.br
\fC#include 'models/SH_ClientsTableModel\&.h'\fP
.br
\fC#include 'models/SH_ServicesTableModel\&.h'\fP
.br
\fC#include 'models/SH_GroupsTableModel\&.h'\fP
.br
\fC#include 'models/SH_User\&.h'\fP
.br
\fC#include 'views/SH_ExtendedQQmlAction\&.h'\fP
.br
\fC#include 'logging/QsLog\&.h'\fP
.br
\fC#include 'logging/QsLogDest\&.h'\fP
.br

.SS "Fonctions"

.in +1c
.ti -1c
.RI "void \fBenableLogging\fP (const QString sLogPath)"
.br
.ti -1c
.RI "void \fBexportlog\fP (QtMsgType type, const QMessageLogContext &context, const QString &msg)"
.br
.ti -1c
.RI "int \fBmain\fP (int argc, char **argv)"
.br
.ti -1c
.RI "void \fBspin\fP (int &iteration)"
.br
.ti -1c
.RI "void \fBstatusChanged\fP (QQmlComponent *component, QQmlComponent::Status status)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const int \fBiterations\fP = 20"
.br
.in -1c
.SH "Documentation des fonctions"
.PP 
.SS "void enableLogging (const QStringsLogPath)"
enableLogging 
.PP
\fBParamètres:\fP
.RS 4
\fIsLogPath\fP 
.RE
.PP

.PP
Définition à la ligne 71 du fichier main\&.cpp\&.
.PP
Référencé par main()\&.
.PP
.nf
72 {
73     /* init the logging mechanism*/
74     QsLogging::Logger& logger = QsLogging::Logger::instance();
75     logger\&.setLoggingLevel(QsLogging::TraceLevel);
76 
77     QsLogging::DestinationPtr fileDestination(
78                 QsLogging::DestinationFactory::MakeFileDestination(sLogPath, true, 512, 2) );
79     QsLogging::DestinationPtr debugDestination(
80                 QsLogging::DestinationFactory::MakeDebugOutputDestination() );
81     logger\&.addDestination(debugDestination);
82     logger\&.addDestination(fileDestination);
83 
84     logger\&.setLoggingLevel(QsLogging::OffLevel); /*truning logging off*/
85 
86 
87     /*qInstallMessageHandler(exportlog);*/
88 
89     /* QLOG_INFO() << "Here is some information";
90 
91         QLOG_TRACE() << "Here's a" << QString::fromUtf8("trace") << "message";
92         QLOG_DEBUG() << "Here's a" << static_cast<int>(QsLogging::DebugLevel) << "message";
93         QLOG_WARN()  << "Uh-oh!";
94         qDebug() << "This message won't be picked up by the logger";
95         QLOG_ERROR() << "An example error has occurred";
96         qWarning() << "Neither will this one";
97         QLOG_FATAL() << "Fatal error example!";*/
98 }
.fi
.SS "void exportlog (QtMsgTypetype, const QMessageLogContext &context, const QString &msg)"

.PP
Définition à la ligne 46 du fichier main\&.cpp\&.
.PP
.nf
46                                                                                       {
47     QFile file(QApplication::applicationDirPath()+"/"+qAppName()+"\&.log");
48     file\&.open(QIODevice::WriteOnly | QIODevice::Append);
49     file\&.write(QString("[")\&.toUtf8()+QDateTime::currentDateTime()\&.toString()\&.toUtf8()+QString("] ")\&.toUtf8());
50     QString typeName;
51     switch (type) {
52     case QtDebugMsg:
53         typeName = QObject::tr("Debug");
54         break;
55     case QtWarningMsg:
56         typeName = QObject::tr("Warning");
57         break;
58     }
59     file\&.write(QObject::tr("%1: %2\r\n")\&.arg(typeName)\&.arg(msg)\&.toUtf8());
60 }
.fi
.SS "int main (intargc, char **argv)"

.PP
Définition à la ligne 125 du fichier main\&.cpp\&.
.PP
Références enableLogging(), et SH_MessageManager::errorMessage()\&.
.PP
.nf
126 {
127     try
128     {
129         qDebug();  /* Un simple retour à la ligne pour un affichage propre dans la console*/
130 
131         QApplication app(argc, argv);
132 
133         const QString sLogPath(QDir::cleanPath(app\&.applicationDirPath()+"/\&.\&./\&.\&./\&.\&./src/PreCheck/debugLog\&.txt"));
134         qDebug() << app\&.applicationDirPath();
135         qDebug() << QDir::cleanPath(app\&.applicationDirPath()+"/\&.\&./\&.\&./\&.\&./src/PreCheck/debugLog\&.txt");
136         enableLogging(sLogPath);
137 
138         QString appName = QString(QObject::tr("precheck"));
139         QString locale = QLocale::system()\&.name();
140         QTranslator translator;
141         if (!QFile::exists(appName + "_" + locale + "\&.qm"))
142         {
143             locale = locale\&.section('_', 0, 0);
144         }
145         if (QFile::exists(appName + "_" + locale + "\&.qm"))
146         {
147             translator\&.load(appName + "_" + locale);
148             app\&.installTranslator(&translator);
149         }
150 
151         QQmlEngine engine;
152 
153         qmlRegisterUncreatableType<SH_ApplicationCore>("PreCheck", 1, 0, "AppMode","pour enum AppMode");
154         qmlRegisterType<SH_User>("PreCheck", 1, 0, "User");
155         SH_ApplicationCore* appManager = new SH_ApplicationCore();
156         engine\&.rootContext()->setContextProperty("App", appManager);
157 
158         qmlRegisterType<SH_RoomsTableModel>("PreCheck", 1, 0, "SH_RoomsModel");
159         qmlRegisterType<SH_BillingsTableModel>("PreCheck", 1, 0, "SH_BillingsModel");
160         qmlRegisterType<SH_BillsTableModel>("PreCheck", 1, 0, "SH_BillsModel");
161         qmlRegisterType<SH_BookingsTableModel>("PreCheck", 1, 0, "SH_BookingsModel");
162         qmlRegisterType<SH_ServicesTableModel>("PreCheck", 1, 0, "SH_ServicesModel");
163         qmlRegisterType<SH_ClientsTableModel>("PreCheck", 1, 0, "SH_ClientsModel");
164         qmlRegisterType<SH_GroupsTableModel>("PreCheck", 1, 0, "SH_GroupsModel");
165         qmlRegisterType<SH_SqlDataFields>("PreCheck", 1, 0, "SH_SqlDataField");
166         qmlRegisterType<SH_ExtendedQQmlAction>("PreCheck", 1, 0, "SH_ComplexAction");
167 
168         QQmlComponent component(&engine);
169         component\&.loadUrl(QUrl("qrc:/qml/SH_app\&.qml"));
170         if (!component\&.isReady())
171         {
172             qWarning("%s", qPrintable(component\&.errorString()));
173             return -1;
174         }
175         QObject *topLevel = component\&.create();
176         QQuickWindow *window = qobject_cast<QQuickWindow *>(topLevel);
177         if (!window)
178         {
179             qWarning("Error: Your root item has to be a Window\&.");
180             return -1;
181         }
182         QObject::connect(&engine, SIGNAL(quit()), &app, SLOT(quit()));
183 
184 
185         QObject * commonPage = window->findChild<QObject *>("Common");
186         QObject * tabsZone = commonPage->findChild<QObject *>("TabView");
187         QObject * displayZone = commonPage->findChild<QObject *>("RightOutput");
188 
189         QObject::connect(appManager, SIGNAL(openTab(QVariant)), tabsZone, SLOT(openTab(QVariant)), Qt::DirectConnection);
190         QObject::connect(appManager, SIGNAL(sendText(QString)), displayZone, SIGNAL(displayNewFixed(QString)), Qt::DirectConnection);
191         QObject::connect(appManager, SIGNAL(sendText(QString)), displayZone, SIGNAL(replace(QString)), Qt::DirectConnection);
192         QObject::connect(appManager, SIGNAL(clearAll()), displayZone, SLOT(clearAll()), Qt::QueuedConnection);
193         /*QObject::connect(appManager, SIGNAL(displayCalendar()), displayZone, SLOT(displayCalendar()), Qt::DirectConnection);*/
194 
195         window->show();
196         QLOG_INFO() << "Program built with Qt" << QT_VERSION_STR << "running on" << qVersion();
197         return app\&.exec();
198 
199     }
200     catch (const std::exception &e)
201     {
202         SH_MessageManager::errorMessage(e\&.what());
203     }
204 }
.fi
.SS "void spin (int &iteration)"

.PP
Définition à la ligne 108 du fichier main\&.cpp\&.
.PP
.nf
109 {
110     const int work = 1000 * 1000 * 40;
111     volatile int v = 0;
112     for (int j = 0; j < work; ++j)
113         ++v;
114 
115     qDebug() << "iteration" << iteration << "in thread" << QThread::currentThreadId();
116 }
.fi
.SS "void statusChanged (QQmlComponent *component, QQmlComponent::Statusstatus)"

.PP
Définition à la ligne 31 du fichier main\&.cpp\&.
.PP
.nf
31                                                                          {
32     if (status == QQmlComponent::Error) {
33         foreach (const QQmlError &error, component->errors()) {
34             const QByteArray file = error\&.url()\&.toEncoded();
35             QMessageLogger(file\&.constData(), error\&.line(), 0)\&.debug() << error\&.description();
36         }
37     }
38 }
.fi
.SH "Documentation des variables"
.PP 
.SS "const int iterations = 20"

.PP
Définition à la ligne 23 du fichier main\&.cpp\&.
.SH "Auteur"
.PP 
Généré automatiquement par Doxygen pour PreCheck à partir du code source\&.
